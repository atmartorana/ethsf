"use strict";

var _slicedToArray2 = require("babel-runtime/helpers/slicedToArray");

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var channelManagerAbi = require("../artifacts/ChannelManager.json");
var util = require("ethereumjs-util");
var Web3 = require("web3");
var validate = require("validate.js");

var _require = require("./helpers/Errors"),
    validateBalance = _require.validateBalance,
    validateTipPurchaseMeta = _require.validateTipPurchaseMeta,
    validatePurchasePurchaseMeta = _require.validatePurchasePurchaseMeta,
    validateWithdrawalPurchaseMeta = _require.validateWithdrawalPurchaseMeta,
    ChannelOpenError = _require.ChannelOpenError,
    ParameterValidationError = _require.ParameterValidationError,
    ContractError = _require.ContractError,
    ThreadOpenError = _require.ThreadOpenError,
    ChannelUpdateError = _require.ChannelUpdateError,
    ThreadUpdateError = _require.ThreadUpdateError,
    ChannelCloseError = _require.ChannelCloseError,
    ThreadCloseError = _require.ThreadCloseError;

var MerkleTree = require("./helpers/MerkleTree");
var Utils = require("./helpers/utils");
var crypto = require("crypto");
var networking = require("./helpers/networking");
var tokenAbi = require("human-standard-token-abi");

// Channel enums
var CHANNEL_STATES = {
  OPENED: 0,
  JOINED: 1,
  SETTLING: 2,
  SETTLED: 3
};

// thread enums
var THREAD_STATES = {
  OPENED: 0,
  JOINED: 1,
  SETTLING: 2,
  SETTLED: 3
};

// Purchase metadata enum
var META_TYPES = {
  TIP: 0,
  PURCHASE: 1,
  UNCATEGORIZED: 2,
  WITHDRAWAL: 3
};

var PAYMENT_TYPES = {
  LEDGER: 0,
  VIRTUAL: 1
};

var CHANNEL_TYPES = {
  ETH: 0,
  TOKEN: 1,
  TOKEN_ETH: 2
};

// ***************************************
// ******* PARAMETER VALIDATION **********
// ***************************************
validate.validators.isPositiveBnString = function (value) {
  var bnVal = void 0;
  if (Web3.utils.isBN(value)) {
    bnVal = value;
  } else {
    // try to convert to BN
    try {
      bnVal = Web3.utils.toBN(value);
    } catch (e) {
      return value + " cannot be converted to BN";
    }
  }

  if (bnVal.isNeg()) {
    return value + " cannot be negative";
  } else {
    return null;
  }
};
validate.validators.isValidChannelType = function (value) {
  if (!value) {
    return "Value vannot be undefined";
  } else if (CHANNEL_TYPES[value] === -1) {
    return value + " is not a valid channel type";
  }
};
validate.validators.isValidDepositObject = function (value) {
  if (!value) {
    return "Value cannot be undefined";
  } else if (!value.tokenDeposit && !value.weiDeposit) {
    return value + " does not contain tokenDeposit or weiDeposit fields";
  }
  if (value.tokenDeposit && !validateBalance(value.tokenDeposit)) {
    return value.tokenDeposit + " is not a valid token deposit";
  }

  if (value.weiDeposit && !validateBalance(value.weiDeposit)) {
    return value.weiDeposit + " is not a valid eth deposit";
  }

  return null;
};

validate.validators.isValidMeta = function (value) {
  if (!value) {
    return "Value cannot be undefined.";
  } else if (!value.receiver) {
    return value + " does not contain a receiver field";
  } else if (!Web3.utils.isAddress(value.receiver)) {
    return value.receiver + " is not a valid ETH address";
  } else if (!value.type) {
    return value + " does not contain a type field";
  }

  var isValid = void 0,
      ans = void 0;

  switch (META_TYPES[value.type]) {
    case 0:
      // TIP
      isValid = validateTipPurchaseMeta(value);
      ans = isValid ? null : JSON.stringify(value) + " is not a valid TIP purchase meta, missing one or more fields: streamId, performerId, performerName";
      return ans;
    case 1:
      // PURCHASE
      isValid = validatePurchasePurchaseMeta(value);
      ans = isValid ? null : JSON.stringify(value) + " is not a valid PURCHASE purchase meta, missing one or more fields: productSku, productName";
      return ans;
    case 2:
      // UNCATEGORIZED -- no validation
      return null;
    case 3:
      // WITHDRAWAL
      isValid = validateWithdrawalPurchaseMeta(value);
      ans = isValid ? null : JSON.stringify(value) + " is not a valid WITHDRAWAL purchase meta.";
      return ans;
    default:
      return value.type + " is not a valid purchase meta type";
  }
};

validate.validators.isChannelStatus = function (value) {
  if (CHANNEL_STATES[value] === null) {
    return null;
  } else {
    return value + " is not a valid lc state";
  }
};

validate.validators.isBN = function (value) {
  if (Web3.utils.isBN(value)) {
    return null;
  } else {
    return value + " is not BN.";
  }
};

validate.validators.isHex = function (value) {
  if (Web3.utils.isHex(value)) {
    return null;
  } else {
    return value + " is not hex string.";
  }
};

validate.validators.isHexStrict = function (value) {
  // for ledgerIDs
  if (Web3.utils.isHexStrict(value)) {
    return null;
  } else {
    return value + " is not hex string prefixed with 0x.";
  }
};

validate.validators.isArray = function (value) {
  if (Array.isArray(value)) {
    return null;
  } else {
    return value + " is not an array.";
  }
};

validate.validators.isObj = function (value) {
  if (value instanceof Object && value) {
    return null;
  } else {
    return value + " is not an object.";
  }
};

validate.validators.isAddress = function (value) {
  if (Web3.utils.isAddress(value)) {
    return null;
  } else {
    return value + " is not address.";
  }
};

validate.validators.isBool = function (value) {
  if ((typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === (0, _typeof3.default)(true)) {
    return null;
  } else {
    return value + " is not a boolean.";
  }
};

validate.validators.isPositiveInt = function (value) {
  if (value >= 0) {
    return null;
  } else {
    return value + " is not a positive integer.";
  }
};

validate.validators.isThreadState = function (value) {
  if (!value.channelId || !Web3.utils.isHexStrict(value.channelId)) {
    return "Thread state does not contain valid channelId: " + JSON.stringify(value);
  }
  if (value.nonce == null || value.nonce < 0) {
    return "Thread state does not contain valid nonce: " + JSON.stringify(value);
  }
  if (!value.partyA || !Web3.utils.isAddress(value.partyA)) {
    return "Thread state does not contain valid partyA: " + JSON.stringify(value);
  }
  if (!value.partyB || !Web3.utils.isAddress(value.partyB)) {
    return "Thread state does not contain valid partyB: " + JSON.stringify(value);
  }
  // valid state may have weiBalanceA/tokenBalanceA
  // or valid states may have balanceA objects
  if (value.weiBalanceA != null) {
    // must also contain all other fields
    if (value.weiBalanceB == null || value.tokenBalanceA == null || value.tokenBalanceB == null) {
      return "Thread state does not contain valid balances: " + JSON.stringify(value);
    }
  } else if (value.balanceA != null) {
    if (validate.validators.isValidDepositObject(value.balanceA) || validate.validators.isValidDepositObject(value.balanceB)) {
      return "Thread state does not contain valid balances: " + JSON.stringify(value);
    }
  } else {
    return "Thread state does not contain valid balances: " + JSON.stringify(value);
  }

  return null;
};

validate.validators.isChannelObj = function (value) {
  if (CHANNEL_STATES[value.status] === null) {
    return "Channel object does not contain valid state: " + JSON.stringify(value);
  }
  if (!value.channelId || !Web3.utils.isHexStrict(value.channelId)) {
    return "Channel object does not contain valid channelId: " + JSON.stringify(value);
  }
  if (value.nonce == null || value.nonce < 0) {
    return "Channel object does not contain valid nonce: " + JSON.stringify(value);
  }
  if (!value.partyA || !Web3.utils.isAddress(value.partyA)) {
    return "Channel object does not contain valid partyA: " + JSON.stringify(value);
  }
  if (!value.partyI || !Web3.utils.isAddress(value.partyI)) {
    return "Channel object does not contain valid partyI: " + JSON.stringify(value);
  }
  if (value.numOpenThread == null || value.numOpenThread < 0) {
    return "Channel object does not contain valid number of numOpenThread: " + JSON.stringify(value);
  }
  if (!value.threadRootHash || !Web3.utils.isHexStrict(value.threadRootHash)) {
    return "Channel object does not contain valid threadRootHash: " + JSON.stringify(value);
  }
  if (value.weiBalanceA == null) {
    return "Channel object does not contain valid weiBalanceA: " + JSON.stringify(value);
  }
  if (value.weiBalanceI == null) {
    return "Channel object does not contain valid weiBalanceI: " + JSON.stringify(value);
  }
  if (value.tokenBalanceA == null) {
    return "Channel object does not contain valid tokenBalanceA: " + JSON.stringify(value);
  }
  if (value.tokenBalanceI == null) {
    return "Channel object does not contain valid tokenBalanceI: " + JSON.stringify(value);
  }
  return null;
};

/**
 *
 * Class representing an instance of a Connext client.
 */

var Connext = function () {
  /**
   *
   * Create an instance of the Connext client. You'll have to pass in a param object.
   *
   * @constructor
   * @example
   * const Connext = require('connext')
   * const connext = new Connext(params)
   * @param {Object} params - the constructor object
   * @param {Web3} params.web3 - the web3 instance
   * @param {String} params.hubAddress - ETH address of the hub
   * @param {String} params.hubUrl - url of hub server
   * @param {String} params.contractAddress - address of deployed ChannelManager contract
   * @param {String} params.hubAuth - token authorizing client package to make requests to hub
   */
  function Connext(_ref) {
    var web3 = _ref.web3,
        _ref$hubAddress = _ref.hubAddress,
        hubAddress = _ref$hubAddress === undefined ? "" : _ref$hubAddress,
        _ref$hubUrl = _ref.hubUrl,
        hubUrl = _ref$hubUrl === undefined ? "" : _ref$hubUrl,
        _ref$contractAddress = _ref.contractAddress,
        contractAddress = _ref$contractAddress === undefined ? "" : _ref$contractAddress,
        _ref$hubAuth = _ref.hubAuth,
        hubAuth = _ref$hubAuth === undefined ? "" : _ref$hubAuth;
    var web3Lib = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Web3;
    (0, _classCallCheck3.default)(this, Connext);

    this.web3 = new web3Lib(web3.currentProvider); // convert legacy web3 0.x to 1.x
    this.hubAddress = hubAddress.toLowerCase();
    this.hubUrl = hubUrl;
    this.channelManagerInstance = new this.web3.eth.Contract(channelManagerAbi.abi, contractAddress);
    this.config = {
      headers: {
        Cookie: "hub.sid=" + hubAuth + ";",
        Authorization: "Bearer " + hubAuth
      },
      withAuth: true
    };
    this.networking = networking(hubUrl, false);
  }

  // ***************************************
  // *********** HAPPY CASE FNS ************
  // ***************************************

  /**
   * Opens a channel with the hub at the address provided when instantiating the Connext instance with the given initial deposits.
   *
   * Uses the internal web3 instance to call the createChannel function on the Channel Manager contract, and logs the transaction hash of the channel creation. The function returns the ID of the created channel.
   *
   * Once the channel is created on chain, users should call the requestJoinChannel function to request that the hub joins the channel with the provided deposit. This deposit is the amount the viewer anticipates others will pay them for the duration of the channel. This function should be called on a timeout sufficient for the hub to detect the channel and add it to its database.
   *
   * If the hub is unresponsive, or does not join the channel within the challenge period, the client function "channelOpenTimeoutContractHandler" can be called by the client to recover the funds.
   *
   * @example
   * // sender must approve token transfer
   * // for channel manager contract address before calling
   * const initialDeposits = {
   *    tokenDeposit: Web3.utils.toBN('1000'),
   *    weiDeposit: Web3.utils.toBN('1000')
   * }
   * const challenge = 3600 // period to wait in disputes
   * const tokenAddress = '0xaacb...'
   * const channelId = await connext.openChannel({ initialDeposits, challenge, tokenAddress })
   *
   * @param {Object} initialDeposits - deposits in wei (must have at least one deposit)
   * @param {BN} initialDeposits.weiDeposit - deposit in wei (may be null for ETH only channels)
   * @param {BN} initialDeposits.tokenDeposit - deposit in tokens (may be null)
   * @param {Number} challenge - challenge period in seconds
   * @param {String} tokenAddress - address of token deposit.
   * @param {String} sender - (optional) counterparty with hub in ledger channel, defaults to accounts[0]
   * @returns {Promise} resolves to the channel id of the created channel
   */


  (0, _createClass3.default)(Connext, [{
    key: "openChannel",
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_ref2) {
        var initialDeposits = _ref2.initialDeposits,
            challenge = _ref2.challenge,
            _ref2$tokenAddress = _ref2.tokenAddress,
            tokenAddress = _ref2$tokenAddress === undefined ? null : _ref2$tokenAddress,
            _ref2$sender = _ref2.sender,
            sender = _ref2$sender === undefined ? null : _ref2$sender;
        var methodName, isValidDepositObject, isAddress, isPositiveInt, accounts, weiDeposit, tokenDeposit, channelType, channel, channelId, contractResult;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // validate params
                methodName = "openChannel";
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isAddress = { presence: true, isAddress: true };
                isPositiveInt = { presence: true, isPositiveInt: true };

                Connext.validatorsResponseToError(validate.single(initialDeposits, isValidDepositObject), methodName, "initialDeposits");
                Connext.validatorsResponseToError(validate.single(challenge, isPositiveInt), methodName, "challenge");
                if (tokenAddress) {
                  Connext.validatorsResponseToError(validate.single(tokenAddress, isAddress), methodName, "tokenAddress");
                }

                if (!sender) {
                  _context.next = 11;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context.next = 15;
                break;

              case 11:
                _context.next = 13;
                return this.web3.eth.getAccounts();

              case 13:
                accounts = _context.sent;

                sender = accounts[0].toLowerCase();

              case 15:

                // determine channel type
                weiDeposit = initialDeposits.weiDeposit, tokenDeposit = initialDeposits.tokenDeposit;
                channelType = void 0;

                if (!(weiDeposit && tokenDeposit)) {
                  _context.next = 21;
                  break;
                }

                // token and eth
                channelType = Object.keys(CHANNEL_TYPES)[2];
                _context.next = 30;
                break;

              case 21:
                if (!tokenDeposit) {
                  _context.next = 25;
                  break;
                }

                channelType = Object.keys(CHANNEL_TYPES)[1];
                _context.next = 30;
                break;

              case 25:
                if (!weiDeposit) {
                  _context.next = 29;
                  break;
                }

                channelType = Object.keys(CHANNEL_TYPES)[0];
                _context.next = 30;
                break;

              case 29:
                throw new ChannelOpenError(methodName, "Error determining channel deposit types.");

              case 30:
                _context.next = 32;
                return this.getChannelByPartyA(sender);

              case 32:
                channel = _context.sent;

                if (!(channel != null && CHANNEL_STATES[channel.status] === CHANNEL_STATES.JOINED)) {
                  _context.next = 35;
                  break;
                }

                throw new ChannelOpenError(methodName, 401, "PartyA has open channel with hub, ID: " + channel.channelId);

              case 35:
                if (!(sender.toLowerCase() === this.hubAddress.toLowerCase())) {
                  _context.next = 37;
                  break;
                }

                throw new ChannelOpenError(methodName, "Cannot open a channel with yourself");

              case 37:

                // generate additional initial lc params
                channelId = Connext.getNewChannelId();
                _context.next = 40;
                return this.createChannelContractHandler({
                  channelId: channelId,
                  challenge: challenge,
                  initialDeposits: initialDeposits,
                  channelType: channelType,
                  tokenAddress: tokenAddress ? tokenAddress : null,
                  sender: sender
                });

              case 40:
                contractResult = _context.sent;

                console.log("tx hash:", contractResult.transactionHash);

                return _context.abrupt("return", channelId);

              case 43:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function openChannel(_x2) {
        return _ref3.apply(this, arguments);
      }

      return openChannel;
    }()

    /**
     * Requests that the hub joins the channel with the provided channelId and deposits.
     *
     * The requested deposit amounts should reflect the amount the channel partyA expects to be paid for the duration of the capital.
     *
     * @example
     * const channelId = await connext.openChannel({ initialDeposits, challenge, tokenAddress })
     * await connext.joinChannel({ channelId })
     *
     * @param {Object} hubDeposit - (optional) requested deposits in the channel from the hub. Defaults to a 0 deposit.
     * @param {BN} hubDeposit.weiDeposit - (optional) weiDeposit requested from hub
     * @param {BN} hubDeposit.tokenDeposit - (optional) tokenDeposit requested from hub.
     * @param {String} channelId - channelId of the channel you would like to join.
     * @returns {Promise} resolves to hubs response to the channel join.
     *
     */

  }, {
    key: "requestJoinChannel",
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(_ref4) {
        var hubDeposit = _ref4.hubDeposit,
            channelId = _ref4.channelId;

        var methodName, isHex, isValidDepositObject, _hubDeposit, weiDeposit, tokenDeposit, response;

        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                methodName = "requestJoinChannel";
                isHex = { presence: true, isHex: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };

                if (hubDeposit) {
                  Connext.validatorsResponseToError(validate.single(hubDeposit, isValidDepositObject), methodName, "hubDeposit");
                } else {
                  hubDeposit = {
                    weiDeposit: Web3.utils.toBN("0"),
                    tokenDeposit: Web3.utils.toBN("0")
                  };
                }

                Connext.validatorsResponseToError(validate.single(channelId, isHex), methodName, "channelId");

                _hubDeposit = hubDeposit, weiDeposit = _hubDeposit.weiDeposit, tokenDeposit = _hubDeposit.tokenDeposit;
                // post to hub join endpoint with same params

                _context2.prev = 6;
                _context2.next = 9;
                return this.networking.post("channel/join", {
                  weiBalanceI: weiDeposit ? weiDeposit.toString() : "0",
                  tokenBalanceI: tokenDeposit ? tokenDeposit.toString() : "0",
                  channelId: channelId
                });

              case 9:
                response = _context2.sent;
                return _context2.abrupt("return", response.data);

              case 13:
                _context2.prev = 13;
                _context2.t0 = _context2["catch"](6);
                throw new ChannelOpenError(methodName, "Error joining channel.");

              case 16:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[6, 13]]);
      }));

      function requestJoinChannel(_x3) {
        return _ref5.apply(this, arguments);
      }

      return requestJoinChannel;
    }()

    /**
     * Adds a deposit to an existing channel by calling the contract function "deposit" using the internal web3 instance.
     *
     * Can be used by any either channel party.
     *
     * If sender is not supplied, it defaults to accounts[0]. If the recipient is not supplied, it defaults to the sender.
     *
     *
     * @example
     * // create deposit object
     * const deposits = {
     *    tokenDeposit: Web3.utils.toBN('1000'),
     *    weiDeposit: Web3.utils.toBN('1000')
     * }
     * const txHash = await connext.deposit(deposit)
     *
     * @param {Object} deposits - deposit object
     * @param {BN} deposits.weiDeposit - value of the channel deposit in ETH
     * @param {BN} deposits.tokenDeposit - value of the channel deposit in tokens
     * @param {String} tokenAddress - (optional, for testing) contract address of channel tokens. If not provided, takes from channel object.
     * @param {String} sender - (optional) ETH address sending funds to the ledger channel
     * @param {String} recipient - (optional) ETH address recieving funds in their ledger channel
     * @returns {Promise} resolves to the transaction hash of the onchain deposit.
     */

  }, {
    key: "deposit",
    value: function () {
      var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(deposits) {
        var sender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var recipient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : sender;
        var tokenAddress = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var methodName, isValidDepositObject, isAddress, accounts, channel, contractResult, sig, newWeiBalanceA, newTokenBalanceA, result;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // validate params
                methodName = "deposit";
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(deposits, isValidDepositObject), methodName, "deposits");
                _context3.next = 6;
                return this.web3.eth.getAccounts();

              case 6:
                accounts = _context3.sent;

                if (sender) {
                  Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                } else {
                  sender = accounts[0].toLowerCase();
                }
                if (recipient) {
                  Connext.validatorsResponseToError(validate.single(recipient, isAddress), methodName, "recipient");
                } else {
                  recipient = accounts[0].toLowerCase();
                }

                _context3.next = 11;
                return this.getChannelByPartyA(recipient);

              case 11:
                channel = _context3.sent;

                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.LCS_OPENED)) {
                  _context3.next = 14;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel is not in the right state");

              case 14:
                if (!(channel.partyA.toLowerCase() !== recipient.toLowerCase() && channel.partyI.toLowerCase() !== recipient.toLowerCase())) {
                  _context3.next = 16;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Recipient is not member of channel");

              case 16:
                _context3.next = 18;
                return this.depositContractHandler({
                  channelId: channel.channelId,
                  deposits: deposits,
                  recipient: recipient,
                  sender: sender,
                  tokenAddress: tokenAddress
                });

              case 18:
                contractResult = _context3.sent;
                sig = void 0;
                // post new sig

                newWeiBalanceA = deposits.weiDeposit ? Web3.utils.toBN(channel.weiBalanceA).add(deposits.weiDeposit) : Web3.utils.toBN(channel.weiBalanceA);
                newTokenBalanceA = deposits.tokenDeposit ? Web3.utils.toBN(channel.tokenBalanceA).add(deposits.tokenDeposit) : Web3.utils.toBN(channel.tokenBalanceA);

                if (!contractResult) {
                  _context3.next = 28;
                  break;
                }

                _context3.next = 25;
                return this.createChannelStateUpdate({
                  channelId: channel.channelId,
                  nonce: channel.nonce + 1,
                  numOpenThread: channel.numOpenThread,
                  threadRootHash: channel.threadRootHash,
                  partyA: channel.partyA,
                  partyI: channel.partyI,
                  balanceA: {
                    weiDeposit: newWeiBalanceA,
                    tokenDeposit: newTokenBalanceA
                  },
                  balanceI: {
                    weiDeposit: Web3.utils.toBN(channel.weiBalanceI),
                    tokenDeposit: Web3.utils.toBN(channel.tokenBalanceI)
                  },
                  deposit: deposits
                });

              case 25:
                sig = _context3.sent;
                _context3.next = 29;
                break;

              case 28:
                throw new ChannelUpdateError(methodName, "Error with contract transaction");

              case 29:
                _context3.next = 31;
                return this.networking.post("channel/" + channel.channelId + "/deposit", {
                  sig: sig,
                  deposit: deposits.weiDeposit ? deposits.weiDeposit.toString() : deposits.tokenDeposit.toString(),
                  isToken: deposits.weiDeposit ? false : true
                });

              case 31:
                result = _context3.sent;
                return _context3.abrupt("return", result.data);

              case 33:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function deposit(_x7) {
        return _ref6.apply(this, arguments);
      }

      return deposit;
    }()

    /**
     * Opens a thread between "to" and "sender" with the hub acting as an intermediary. Both users must have a channel open with the hub.
     *
     * If there is no deposit provided, then 100% of the channel balance is added to the thread. This function is to be called by the payor (sender), and is intended to open a unidirectional channel with the payee (to).
     *
     * Signs a copy of the initial thread state, and generates a proposed channel update to the hub for countersigning reflecting the thread creation.
     *
     * @example
     * const myFriendsAddress = "0x627306090abaB3A6e1400e9345bC60c78a8BEf57"
     * await connext.openThread({ to: myFriendsAddress })
     *
     * @param {Object} params - the method object
     * @param {String} params.to - ETH address you want to open a virtual channel with
     * @param {Object} params.deposit - (optional) deposit object for the virtual channel, defaults to the entire channel balances
     * @param {Object} params.deposit.weiDeposit - (optional) wei deposit into thread
     * @param {BN} params.deposit.weiDeposit - token deposit into thread
     * @param {String} params.sender - (optional) who is initiating the virtual channel creation, defaults to accounts[0]
     * @returns {Promise} resolves to the virtual channel ID recieved by Ingrid
     */

  }, {
    key: "openThread",
    value: function () {
      var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(_ref7) {
        var to = _ref7.to,
            _ref7$deposit = _ref7.deposit,
            deposit = _ref7$deposit === undefined ? null : _ref7$deposit,
            _ref7$sender = _ref7.sender,
            sender = _ref7$sender === undefined ? null : _ref7$sender;
        var methodName, isAddress, isValidDepositObject, accounts, subchanA, subchanB, thread, updateType, threadId, threadInitialState, threadSig, channelSig, response;
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                // validate params
                methodName = "openThread";
                isAddress = { presence: true, isAddress: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };

                Connext.validatorsResponseToError(validate.single(to, isAddress), methodName, "to");
                if (deposit) {
                  Connext.validatorsResponseToError(validate.single(deposit, isValidDepositObject), methodName, "deposit");
                }

                if (!sender) {
                  _context4.next = 9;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context4.next = 13;
                break;

              case 9:
                _context4.next = 11;
                return this.web3.eth.getAccounts();

              case 11:
                accounts = _context4.sent;

                sender = accounts[0].toLowerCase();

              case 13:
                if (!(sender.toLowerCase() === to.toLowerCase())) {
                  _context4.next = 15;
                  break;
                }

                throw new ThreadOpenError(methodName, "Cannot open a channel with yourself");

              case 15:
                _context4.next = 17;
                return this.getChannelByPartyA(sender);

              case 17:
                subchanA = _context4.sent;
                _context4.next = 20;
                return this.getChannelByPartyA(to);

              case 20:
                subchanB = _context4.sent;

                if (!(!subchanB || !subchanA)) {
                  _context4.next = 23;
                  break;
                }

                throw new ThreadOpenError(methodName, "Missing one or more required subchannels");

              case 23:
                if (!(subchanB.status !== Object.keys(CHANNEL_STATES)[CHANNEL_STATES.JOINED] || subchanA.status !== Object.keys(CHANNEL_STATES)[CHANNEL_STATES.JOINED])) {
                  _context4.next = 25;
                  break;
                }

                throw new ThreadOpenError(methodName, "One or more required subchannels are in the incorrect state");

              case 25:

                // validate subchanA has enough to deposit or set deposit
                if (deposit === null) {
                  // use entire subchanA balance
                  deposit = {
                    tokenDeposit: Web3.utils.toBN(subchanA.tokenBalanceA),
                    weiDeposit: Web3.utils.toBN(subchanA.weiBalanceA)
                  };
                }

                if (!(deposit.tokenDeposit && Web3.utils.toBN(subchanA.tokenBalanceA).lt(deposit.tokenDeposit))) {
                  _context4.next = 28;
                  break;
                }

                throw new ThreadOpenError(methodName, "Insufficient value to open channel with provided token deposit");

              case 28:
                if (!(deposit.weiDeposit && Web3.utils.toBN(subchanA.weiBalanceA).lt(deposit.weiDeposit))) {
                  _context4.next = 30;
                  break;
                }

                throw new ThreadOpenError(methodName, "Insufficient value to open channel with provided ETH deposit");

              case 30:
                _context4.next = 32;
                return this.getThreadByParties({ partyA: sender, partyB: to });

              case 32:
                thread = _context4.sent;

                if (!thread) {
                  _context4.next = 35;
                  break;
                }

                throw new ThreadOpenError(methodName, 451, "Parties already have open virtual channel: " + thread.channelId);

              case 35:

                // detemine update type
                updateType = void 0;

                if (!(deposit.weiDeposit && deposit.tokenDeposit)) {
                  _context4.next = 40;
                  break;
                }

                // token and eth
                updateType = Object.keys(CHANNEL_TYPES)[2];
                _context4.next = 49;
                break;

              case 40:
                if (!deposit.tokenDeposit) {
                  _context4.next = 44;
                  break;
                }

                updateType = Object.keys(CHANNEL_TYPES)[1];
                _context4.next = 49;
                break;

              case 44:
                if (!deposit.weiDeposit) {
                  _context4.next = 48;
                  break;
                }

                updateType = Object.keys(CHANNEL_TYPES)[0];
                _context4.next = 49;
                break;

              case 48:
                throw new ThreadOpenError(methodName, "Error determining channel deposit types.");

              case 49:

                // generate initial vcstate
                threadId = Connext.getNewChannelId();
                threadInitialState = {
                  channelId: threadId,
                  nonce: 0,
                  partyA: sender,
                  partyB: to.toLowerCase(),
                  balanceA: deposit,
                  balanceB: {
                    tokenDeposit: Web3.utils.toBN("0"),
                    weiDeposit: Web3.utils.toBN("0")
                  },
                  updateType: updateType,
                  signer: sender
                };
                _context4.next = 53;
                return this.createThreadStateUpdate(threadInitialState);

              case 53:
                threadSig = _context4.sent;
                _context4.next = 56;
                return this.createChannelUpdateOnThreadOpen({
                  threadInitialState: threadInitialState,
                  subchan: subchanA,
                  signer: sender
                });

              case 56:
                channelSig = _context4.sent;
                _context4.prev = 57;
                _context4.next = 60;
                return this.networking.post("thread/", {
                  threadId: threadId,
                  partyA: sender.toLowerCase(),
                  partyB: to.toLowerCase(),
                  partyI: subchanA.partyI,
                  subchanA: subchanA.channelId,
                  subchanB: subchanB.channelId,
                  weiBalanceA: deposit.weiDeposit ? deposit.weiDeposit.toString() : "0",
                  weiBalanceB: "0",
                  tokenBalanceA: deposit.tokenDeposit ? deposit.tokenDeposit.toString() : "0",
                  weiBond: deposit.weiDeposit ? deposit.weiDeposit.toString() : "0",
                  tokenBond: deposit.tokenDeposit ? deposit.tokenDeposit.toString() : "0",
                  tokenBalanceB: "0",
                  threadSig: threadSig,
                  channelSig: channelSig
                });

              case 60:
                response = _context4.sent;
                _context4.next = 66;
                break;

              case 63:
                _context4.prev = 63;
                _context4.t0 = _context4["catch"](57);
                throw new ThreadOpenError(methodName, _context4.t0.message);

              case 66:
                return _context4.abrupt("return", threadId);

              case 67:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[57, 63]]);
      }));

      function openThread(_x8) {
        return _ref8.apply(this, arguments);
      }

      return openThread;
    }()

    /**
     * Sends a state update in a channel. Updates of these type represent an in channel payment to or from the hub.
     *
     * The balance objects represent the final balances of partyA (balanceA) and the hub (balanceB) following the update.
     *
     * @example
     * const { channelId } = await connext.getChannelByPartyA()
     * const payment = Web3.utils.toBN('10')
     * const balanceA = {
     *    tokenDeposit: Web3.utils.toBN(channel.tokenBalanceA).sub(payment),
     *    weiDeposit: Web3.utils.toBN(channel.weiBalanceA).sub(payment)
     * }
     * const balanceB = {
     *    tokenDeposit: Web3.utils.toBN(channel.tokenBalanceA).add(payment),
     *    weiDeposit: Web3.utils.toBN(channel.weiBalanceA).add(payment)
     * }
     * await connext.updateChannel({ channelId, balanceA, balanceB })
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - the channelId of the channel you are updating
     * @param {Object} params.balanceA - final balance of partyA in channel
     * @param {BN} params.balanceA.weiDeposit - (optional) final wei balance of partyA in channel
     * @param {BN} params.balanceA.tokenDeposit - (optional) final token balance of partyA in channel
     * @param {Object} params.balanceB - final balance of hub in channel
     * @param {BN} params.balanceB.weiDeposit - (optional) final wei balance of hub in channel
     * @param {BN} params.balanceB.tokenDeposit - (optional) final token balance of hub in channel
     *
     */

  }, {
    key: "updateChannel",
    value: function () {
      var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(_ref9) {
        var channelId = _ref9.channelId,
            balanceA = _ref9.balanceA,
            balanceB = _ref9.balanceB,
            _ref9$sender = _ref9.sender,
            sender = _ref9$sender === undefined ? null : _ref9$sender;
        var methodName, isAddress, isHexStrict, isValidDepositObject, accounts, channel, updateType, channelWeiBal, channelTokenBal, proposedWeiBalance, proposedTokenBalance, state, sig, response;
        return _regenerator2.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                methodName = "channelUpdateHandler";
                isAddress = { presence: true, isAddress: true };
                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };

                if (sender) {
                  _context5.next = 9;
                  break;
                }

                _context5.next = 7;
                return this.web3.eth.getAccounts();

              case 7:
                accounts = _context5.sent;

                sender = accounts[0];

              case 9:
                // validate inputs
                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceB, isValidDepositObject), methodName, "balanceB");
                _context5.next = 15;
                return this.getChannelById(channelId);

              case 15:
                channel = _context5.sent;

                if (channel) {
                  _context5.next = 18;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel not found");

              case 18:
                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.JOINED)) {
                  _context5.next = 20;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel is in invalid state");

              case 20:
                if (!(channel.partyA.toLowerCase() !== sender.toLowerCase() && channel.partyI.toLowerCase() !== sender.toLowerCase())) {
                  _context5.next = 22;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Not your channel");

              case 22:
                // check what type of update
                updateType = void 0;

                if (balanceA.weiDeposit && balanceA.tokenDeposit && balanceB.weiDeposit && balanceB.tokenDeposit) {
                  // token and eth
                  updateType = Object.keys(CHANNEL_TYPES)[2];
                } else if (balanceA.tokenDeposit && balanceB.tokenDeposit) {
                  updateType = Object.keys(CHANNEL_TYPES)[1];
                } else if (balanceA.weiDeposit && balanceB.weiDeposit) {
                  updateType = Object.keys(CHANNEL_TYPES)[0];
                }

                channelWeiBal = Web3.utils.toBN(channel.weiBalanceA).add(Web3.utils.toBN(channel.weiBalanceI));
                channelTokenBal = Web3.utils.toBN(channel.tokenBalanceA).add(Web3.utils.toBN(channel.tokenBalanceI));
                proposedWeiBalance = void 0, proposedTokenBalance = void 0;
                _context5.t0 = CHANNEL_TYPES[updateType];
                _context5.next = _context5.t0 === CHANNEL_TYPES.ETH ? 30 : _context5.t0 === CHANNEL_TYPES.TOKEN ? 34 : _context5.t0 === CHANNEL_TYPES.TOKEN_ETH ? 38 : 45;
                break;

              case 30:
                if (!balanceB.weiDeposit.lte(Web3.utils.toBN(channel.weiBalanceI))) {
                  _context5.next = 32;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel updates can only increase hub ETH balance");

              case 32:
                proposedWeiBalance = Web3.utils.toBN(balanceA.weiDeposit).add(balanceB.weiDeposit); // proposed balance
                return _context5.abrupt("break", 46);

              case 34:
                if (!balanceB.tokenDeposit.lte(Web3.utils.toBN(channel.tokenBalanceI))) {
                  _context5.next = 36;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel updates can only increase hub balance");

              case 36:
                proposedTokenBalance = Web3.utils.toBN(balanceA.tokenDeposit).add(balanceB.tokenDeposit);
                return _context5.abrupt("break", 46);

              case 38:
                if (!balanceB.weiDeposit.lte(Web3.utils.toBN(channel.weiBalanceI))) {
                  _context5.next = 40;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel updates can only increase hub ETH balance");

              case 40:
                if (!balanceB.tokenDeposit.lte(Web3.utils.toBN(channel.tokenBalanceI))) {
                  _context5.next = 42;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel updates can only increase hub balance");

              case 42:
                proposedWeiBalance = Web3.utils.toBN(balanceA.weiDeposit).add(balanceB.weiDeposit);
                proposedTokenBalance = Web3.utils.toBN(balanceA.tokenDeposit).add(balanceB.tokenDeposit);
                return _context5.abrupt("break", 46);

              case 45:
                throw new ChannelUpdateError(methodName, "Error determining channel deposit types.");

              case 46:
                if (!(proposedWeiBalance && !proposedWeiBalance.eq(channelWeiBal))) {
                  _context5.next = 48;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel ETH balance cannot change");

              case 48:
                if (!(proposedTokenBalance && !proposedTokenBalance.eq(channelTokenBal))) {
                  _context5.next = 50;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel token balance cannot change");

              case 50:

                // generate signature
                state = {
                  channelId: channelId,
                  nonce: channel.nonce + 1,
                  numOpenThread: channel.numOpenThread,
                  threadRootHash: channel.threadRootHash,
                  partyA: channel.partyA,
                  partyI: channel.partyI,
                  balanceA: balanceA,
                  balanceI: balanceB,
                  signer: sender
                };
                _context5.next = 53;
                return this.createChannelStateUpdate(state);

              case 53:
                sig = _context5.sent;
                _context5.next = 56;
                return this.networking.post("channel/" + channelId + "/update", {
                  nonce: state.nonce,
                  weiBalanceA: balanceA.weiDeposit ? balanceA.weiDeposit.toString() : "0",
                  weiBalanceI: balanceB.weiDeposit ? balanceB.weiDeposit.toString() : "0",
                  tokenBalanceA: balanceA.tokenDeposit ? balanceA.tokenDeposit.toString() : "0",
                  tokenBalanceI: balanceB.tokenDeposit ? balanceB.tokenDeposit.toString() : "0",
                  threadRootHash: state.threadRootHash,
                  numOpenThread: state.numOpenThread,
                  sigA: sig,
                  sigI: ""
                });

              case 56:
                response = _context5.sent;
                return _context5.abrupt("return", response.data);

              case 58:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function updateChannel(_x9) {
        return _ref10.apply(this, arguments);
      }

      return updateChannel;
    }()

    /**
     * Sends a state update in a thread. Updates of these type are unidirectional and can only facilitate payments from thread partyA to thread partyB.
     *
     * The balance objects represent the final balances of partyA (balanceA) and the hub (partyB) following the update.
     *
     * @example
     * const { threadId } = await connext.getThreadByParties({ partyA, partyB })
     * const payment = Web3.utils.toBN('10')
     * const balanceA = {
     *    tokenDeposit: Web3.utils.toBN(channel.tokenBalanceA).sub(payment),
     *    weiDeposit: Web3.utils.toBN(channel.weiBalanceA).sub(payment)
     * }
     * const balanceB = {
     *    tokenDeposit: Web3.utils.toBN(channel.tokenBalanceA).add(payment),
     *    weiDeposit: Web3.utils.toBN(channel.weiBalanceA).add(payment)
     * }
     * await connext.updateThread({ threadId, balanceA, balanceB })
     *
     * @param {String} threadId - the threadId of the thread you are updating
     * @param {Object} balanceA - final balance of partyA in thread
     * @param {BN} balanceA.weiDeposit - (optional) final wei balance of partyA in thread
     * @param {BN} balanceA.tokenDeposit - (optional) final token balance of partyA in thread
     * @param {Object} balanceB - final balance of partyB in thread
     * @param {BN} balanceB.weiDeposit - (optional) final wei balance of partyB in thread
     * @param {BN} balanceB.tokenDeposit - (optional) final token balance of partyB in thread
     * @param {String} sender - (optional) signer of balance update, defaults to accounts[0]
     *
     */

  }, {
    key: "updateThread",
    value: function () {
      var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(_ref11) {
        var threadId = _ref11.threadId,
            balanceA = _ref11.balanceA,
            balanceB = _ref11.balanceB,
            _ref11$sender = _ref11.sender,
            sender = _ref11$sender === undefined ? null : _ref11$sender;
        var methodName, isHexStrict, isValidDepositObject, isAddress, accounts, thread, updateType, threadEthBalance, threadTokenBalance, proposedWeiBalance, proposedTokenBalance, state, sig, response;
        return _regenerator2.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                // validate params
                methodName = "updateThread";
                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isAddress = { presence: true, isAddress: true };

                if (sender) {
                  _context6.next = 9;
                  break;
                }

                _context6.next = 7;
                return this.web3.eth.getAccounts();

              case 7:
                accounts = _context6.sent;

                sender = accounts[0];

              case 9:
                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceB, isValidDepositObject), methodName, "balanceB");
                // get the thread
                _context6.next = 15;
                return this.getThreadById(threadId);

              case 15:
                thread = _context6.sent;

                if (thread) {
                  _context6.next = 18;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread not found");

              case 18:
                if (!(THREAD_STATES[thread.status] === 3)) {
                  _context6.next = 20;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread is in invalid state");

              case 20:
                if (!(sender.toLowerCase() !== thread.partyA.toLowerCase())) {
                  _context6.next = 22;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only be made by partyA.");

              case 22:

                // check what type of update
                updateType = void 0;

                if (balanceA.weiDeposit && balanceA.tokenDeposit && balanceB.weiDeposit && balanceB.tokenDeposit) {
                  // token and eth
                  updateType = Object.keys(CHANNEL_TYPES)[2];
                } else if (balanceA.tokenDeposit && balanceB.tokenDeposit) {
                  updateType = Object.keys(CHANNEL_TYPES)[1];
                } else if (balanceA.weiDeposit && balanceB.weiDeposit) {
                  updateType = Object.keys(CHANNEL_TYPES)[0];
                }

                threadEthBalance = Web3.utils.toBN(thread.weiBalanceA).add(Web3.utils.toBN(thread.weiBalanceB));
                threadTokenBalance = Web3.utils.toBN(thread.tokenBalanceA).add(Web3.utils.toBN(thread.tokenBalanceB));
                proposedWeiBalance = void 0, proposedTokenBalance = void 0;
                _context6.t0 = CHANNEL_TYPES[updateType];
                _context6.next = _context6.t0 === CHANNEL_TYPES.ETH ? 30 : _context6.t0 === CHANNEL_TYPES.TOKEN ? 34 : _context6.t0 === CHANNEL_TYPES.TOKEN_ETH ? 38 : 45;
                break;

              case 30:
                if (!balanceB.weiDeposit.lte(Web3.utils.toBN(thread.weiBalanceB))) {
                  _context6.next = 32;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB ETH balance");

              case 32:
                proposedWeiBalance = Web3.utils.toBN(balanceA.weiDeposit).add(balanceB.weiDeposit); // proposed balance
                return _context6.abrupt("break", 46);

              case 34:
                if (!balanceB.tokenDeposit.lte(Web3.utils.toBN(thread.tokenBalanceB))) {
                  _context6.next = 36;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB token balance");

              case 36:
                proposedTokenBalance = Web3.utils.toBN(balanceA.tokenDeposit).add(balanceB.tokenDeposit);
                return _context6.abrupt("break", 46);

              case 38:
                if (!balanceB.weiDeposit.lte(Web3.utils.toBN(thread.weiBalanceB))) {
                  _context6.next = 40;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB ETH balance");

              case 40:
                if (!balanceB.tokenDeposit.lte(Web3.utils.toBN(thread.tokenBalanceB))) {
                  _context6.next = 42;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB token balance");

              case 42:
                proposedWeiBalance = Web3.utils.toBN(balanceA.weiDeposit).add(balanceB.weiDeposit);
                proposedTokenBalance = Web3.utils.toBN(balanceA.tokenDeposit).add(balanceB.tokenDeposit);
                return _context6.abrupt("break", 46);

              case 45:
                throw new ThreadUpdateError(methodName, "Error determining thread deposit types.");

              case 46:
                if (!(proposedWeiBalance && !proposedWeiBalance.eq(threadEthBalance))) {
                  _context6.next = 48;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread ETH balance cannot change");

              case 48:
                if (!(proposedTokenBalance && !proposedTokenBalance.eq(threadTokenBalance))) {
                  _context6.next = 50;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread token balance cannot change");

              case 50:

                // generate new state update
                state = {
                  channelId: threadId,
                  nonce: thread.nonce + 1,
                  partyA: thread.partyA,
                  partyB: thread.partyB,
                  balanceA: balanceA,
                  balanceB: balanceB,
                  updateType: updateType,
                  signer: sender
                };
                _context6.next = 53;
                return this.createThreadStateUpdate(state);

              case 53:
                sig = _context6.sent;
                _context6.next = 56;
                return this.networking.post("thread/" + threadId + "/update", {
                  weiBalanceA: proposedWeiBalance ? balanceA.weiDeposit.toString() : Web3.utils.toBN(thread.weiBalanceA).toString(),
                  weiBalanceB: proposedWeiBalance ? balanceB.weiDeposit.toString() : Web3.utils.toBN(thread.weiBalanceB).toString(),
                  tokenBalanceA: proposedTokenBalance ? balanceA.tokenDeposit.toString() : Web3.utils.toBN(thread.tokenBalanceA).toString(),
                  tokenBalanceB: proposedTokenBalance ? balanceB.tokenDeposit.toString() : Web3.utils.toBN(thread.tokenBalanceB).toString(),
                  nonce: thread.nonce + 1,
                  sigA: sig
                });

              case 56:
                response = _context6.sent;
                return _context6.abrupt("return", response.data);

              case 58:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function updateThread(_x10) {
        return _ref12.apply(this, arguments);
      }

      return updateThread;
    }()

    /**
     * Closes a thread. May be called by either member of the thread.
     *
     * Retrieves the latest thread update, and decomposes it into the final channel updates for the subchans.
     *
     * The thread agent who called this function signs the closing channel update, and forwards the signature to the hub.
     *
     * The hub verifies the signature, returns its signature of the channel update, and proposes the corresponding update for the other thread participant.
     *
     * If the hub does not cosign the proposed channel update, the caller may enter the on-chain dispute phase calling updateChannelState, initThread, settleThread, and withdraw.
     *
     * @example
     * const { threadId } = await connext.getThreadByParties({ partyA, partyB })
     * await connext.closeThread(threadId)
     * @param {String} threadId - ID of the thread to close
     * @param {String} sender - (optional) sender of the closeThread account. Default to accounts[0]. Must be partyA or partyB in thread.
     * @returns {Promise} resolves to true if the thread was closed otherwise throws an error
     */

  }, {
    key: "closeThread",
    value: function () {
      var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(threadId) {
        var sender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var methodName, isHexStrict, isAddress, accounts, thread, latestThreadState, weiBalanceA, weiBalanceB, tokenBalanceA, tokenBalanceB, signer, subchan, sigAtoI, fastCloseSig;
        return _regenerator2.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                // validate params
                methodName = "closeThread";
                isHexStrict = { presence: true, isHexStrict: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");

                if (!sender) {
                  _context7.next = 8;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context7.next = 12;
                break;

              case 8:
                _context7.next = 10;
                return this.web3.eth.getAccounts();

              case 10:
                accounts = _context7.sent;

                sender = accounts[0].toLowerCase();

              case 12:
                _context7.next = 14;
                return this.getThreadById(threadId);

              case 14:
                thread = _context7.sent;

                if (thread) {
                  _context7.next = 17;
                  break;
                }

                throw new ThreadCloseError(methodName, "Thread not found");

              case 17:
                if (!(THREAD_STATES[thread.status] !== THREAD_STATES.OPENED && THREAD_STATES[thread.status] !== THREAD_STATES.JOINED)) {
                  _context7.next = 19;
                  break;
                }

                throw new ThreadCloseError(methodName, "Thread is in invalid state");

              case 19:
                _context7.next = 21;
                return this.getLatestThreadState(threadId);

              case 21:
                latestThreadState = _context7.sent;
                weiBalanceA = Web3.utils.toBN(latestThreadState.weiBalanceA);
                weiBalanceB = Web3.utils.toBN(latestThreadState.weiBalanceB);
                tokenBalanceA = Web3.utils.toBN(latestThreadState.tokenBalanceA);
                tokenBalanceB = Web3.utils.toBN(latestThreadState.tokenBalanceB);
                // verify latestThreadState was signed by agentA

                signer = Connext.recoverSignerFromThreadStateUpdate({
                  sig: latestThreadState.sigA,
                  channelId: threadId,
                  nonce: latestThreadState.nonce,
                  partyA: thread.partyA,
                  partyB: thread.partyB,
                  weiBalanceA: weiBalanceA,
                  weiBalanceB: weiBalanceB,
                  tokenBalanceA: tokenBalanceA,
                  tokenBalanceB: tokenBalanceB,
                  weiBond: weiBalanceA.add(weiBalanceB),
                  tokenBond: tokenBalanceA.add(tokenBalanceB)
                });

                if (!(signer.toLowerCase() !== thread.partyA.toLowerCase())) {
                  _context7.next = 29;
                  break;
                }

                throw new ThreadCloseError(methodName, "Incorrect signer detected on latest thread update");

              case 29:

                latestThreadState.threadId = threadId;
                latestThreadState.channelId = threadId;
                latestThreadState.partyA = thread.partyA;
                latestThreadState.partyB = thread.partyB;
                // get partyA channel
                _context7.next = 35;
                return this.getChannelByPartyA(sender);

              case 35:
                subchan = _context7.sent;
                _context7.next = 38;
                return this.createChannelUpdateOnThreadClose({
                  latestThreadState: latestThreadState,
                  subchan: subchan,
                  signer: sender.toLowerCase()
                });

              case 38:
                sigAtoI = _context7.sent;
                _context7.next = 41;
                return this.fastCloseThreadHandler({
                  sig: sigAtoI,
                  signer: sender.toLowerCase(),
                  threadId: threadId
                });

              case 41:
                fastCloseSig = _context7.sent;

                if (fastCloseSig) {
                  _context7.next = 44;
                  break;
                }

                throw new ThreadCloseError(methodName, 651, "Hub did not cosign proposed channel update, call initThread and settleThread");

              case 44:
                return _context7.abrupt("return", fastCloseSig);

              case 45:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function closeThread(_x12) {
        return _ref13.apply(this, arguments);
      }

      return closeThread;
    }()

    /**
     * Closes many threads by calling closeThread on each threadID in the provided array.
     *
     * @example
     * const threads = [
     *     0xasd310..,
     *     0xadsf11..,
     * ]
     * await connext.closeThreads(channels)
     * @param {String[]} threadIds - array of virtual channel IDs you wish to close
     * @param {String} sender - (optional) sender of closeThreads call, must be partyA or partyB in thread. Defaults to accounts[0]
     */

  }, {
    key: "closeThreads",
    value: function () {
      var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(threadIds) {
        var _this = this;

        var sender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var methodName, isArray, isAddress, accounts, fnMap, results, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _ref15, _ref16, parameters, fn, result;

        return _regenerator2.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                methodName = "closeThreads";
                isArray = { presence: true, isArray: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(threadIds, isArray), methodName, "threadIds");

                if (sender) {
                  _context8.next = 9;
                  break;
                }

                _context8.next = 7;
                return this.web3.eth.getAccounts();

              case 7:
                accounts = _context8.sent;

                sender = accounts[0];

              case 9:
                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                // should this try to fast close any of the channels?
                // or just immediately force close in dispute many channels
                fnMap = new Map();

                threadIds.map(function (threadId) {
                  return fnMap.set([threadId, sender], _this.closeThread);
                });
                results = [];
                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context8.prev = 16;
                _iterator = fnMap.entries()[Symbol.iterator]();

              case 18:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context8.next = 39;
                  break;
                }

                _ref15 = _step.value;
                _ref16 = (0, _slicedToArray3.default)(_ref15, 2);
                parameters = _ref16[0];
                fn = _ref16[1];
                _context8.prev = 23;

                console.log("Closing channel: " + parameters[0] + "...");
                _context8.next = 27;
                return fn.apply(this, parameters);

              case 27:
                result = _context8.sent;

                results.push(result);
                console.log("Channel closed.");
                _context8.next = 36;
                break;

              case 32:
                _context8.prev = 32;
                _context8.t0 = _context8["catch"](23);

                console.log("Error closing channel.");
                results.push(new ThreadCloseError(methodName, _context8.t0.message));

              case 36:
                _iteratorNormalCompletion = true;
                _context8.next = 18;
                break;

              case 39:
                _context8.next = 45;
                break;

              case 41:
                _context8.prev = 41;
                _context8.t1 = _context8["catch"](16);
                _didIteratorError = true;
                _iteratorError = _context8.t1;

              case 45:
                _context8.prev = 45;
                _context8.prev = 46;

                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }

              case 48:
                _context8.prev = 48;

                if (!_didIteratorError) {
                  _context8.next = 51;
                  break;
                }

                throw _iteratorError;

              case 51:
                return _context8.finish(48);

              case 52:
                return _context8.finish(45);

              case 53:
                return _context8.abrupt("return", results);

              case 54:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[16, 41, 45, 53], [23, 32], [46,, 48, 52]]);
      }));

      function closeThreads(_x14) {
        return _ref14.apply(this, arguments);
      }

      return closeThreads;
    }()

    /**
     * Closes an existing channel.
     *
     * All threads must be closed before a channel can be closed.
     *
     * Generates the state update from the latest hub signed state with fast-close flag.
     *
     * The hub countersigns the closing update if it matches what has been signed previously, and the channel will fast close by calling consensusCloseChannel on the contract.
     *
     * If the state update doesn't match what the hub previously signed, an error is thrown and the wallet should enter the dispute fase by calling updateChannelState with the fastCloseFlad, then withdraw.
     *
     * @example
     * const success = await connext.closeChannel()
     *
     * @param {String} sender - (optional) who the transactions should be sent from, defaults to accounts[0]
     * @returns {Promise} resolves to the on chain transaction hash of the consensusClose function
     */

  }, {
    key: "closeChannel",
    value: function () {
      var _ref17 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
        var sender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var methodName, isAddress, accounts, channel, channelState, signer, sigParams, sig, finalState, response;
        return _regenerator2.default.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                methodName = "closeChannel";
                isAddress = { presence: true, isAddress: true };

                if (!sender) {
                  _context9.next = 6;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context9.next = 10;
                break;

              case 6:
                _context9.next = 8;
                return this.web3.eth.getAccounts();

              case 8:
                accounts = _context9.sent;

                sender = accounts[0].toLowerCase();

              case 10:
                _context9.next = 12;
                return this.getChannelByPartyA(sender.toLowerCase());

              case 12:
                channel = _context9.sent;

                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.JOINED)) {
                  _context9.next = 15;
                  break;
                }

                throw new ChannelCloseError(methodName, "Channel is in invalid state");

              case 15:
                if (!(sender.toLowerCase() !== channel.partyA && sender.toLowerCase() !== channel.partyI)) {
                  _context9.next = 17;
                  break;
                }

                throw new ChannelCloseError(methodName, "Not your channel");

              case 17:
                _context9.next = 19;
                return this.getLatestChannelState(channel.channelId);

              case 19:
                channelState = _context9.sent;

                if (!channelState) {
                  _context9.next = 30;
                  break;
                }

                if (!(Number(channelState.numOpenThread) !== 0)) {
                  _context9.next = 23;
                  break;
                }

                throw new ChannelCloseError(methodName, "Cannot close channel with open VCs");

              case 23:
                if (!(channelState.threadRootHash !== Connext.generateThreadRootHash({ threadInitialStates: [] }))) {
                  _context9.next = 25;
                  break;
                }

                throw new ChannelCloseError(methodName, "Cannot close channel with open VCs");

              case 25:

                // i-signed?
                signer = Connext.recoverSignerFromChannelStateUpdate({
                  sig: channelState.sigI,
                  isClose: false,
                  channelId: channel.channelId,
                  nonce: channelState.nonce,
                  numOpenThread: channelState.numOpenThread,
                  threadRootHash: channelState.threadRootHash,
                  partyA: channel.partyA,
                  partyI: channel.partyI,
                  weiBalanceA: Web3.utils.toBN(channelState.weiBalanceA),
                  weiBalanceI: Web3.utils.toBN(channelState.weiBalanceI),
                  tokenBalanceA: Web3.utils.toBN(channelState.tokenBalanceA),
                  tokenBalanceI: Web3.utils.toBN(channelState.tokenBalanceI)
                });

                if (!(signer.toLowerCase() !== channel.partyI.toLowerCase())) {
                  _context9.next = 28;
                  break;
                }

                throw new ChannelCloseError(methodName, "Hub did not sign update");

              case 28:
                _context9.next = 31;
                break;

              case 30:
                // no state updates made in LC
                // PROBLEM: ingrid doesnt return lcState, just uses empty
                channelState = {
                  isClose: false,
                  channelId: channel.channelId,
                  nonce: 0,
                  numOpenThread: 0,
                  threadRootHash: Connext.generateThreadRootHash({
                    threadInitialStates: []
                  }),
                  partyA: channel.partyA,
                  partyI: channel.partyI,
                  weiBalanceA: Web3.utils.toBN(channel.weiBalanceA),
                  weiBalanceI: Web3.utils.toBN(channel.weiBalanceI),
                  tokenBalanceA: Web3.utils.toBN(channel.tokenBalanceA),
                  tokenBalanceI: Web3.utils.toBN(channel.tokenBalanceI)
                };

              case 31:

                // generate same update with fast close flag and post
                sigParams = {
                  isClose: true,
                  channelId: channel.channelId,
                  nonce: channelState.nonce + 1,
                  numOpenThread: channelState.numOpenThread,
                  threadRootHash: channelState.threadRootHash,
                  partyA: channel.partyA,
                  partyI: channel.partyI,
                  balanceA: {
                    tokenDeposit: Web3.utils.toBN(channelState.tokenBalanceA),
                    weiDeposit: Web3.utils.toBN(channelState.weiBalanceA)
                  },
                  balanceI: {
                    tokenDeposit: Web3.utils.toBN(channelState.tokenBalanceI),
                    weiDeposit: Web3.utils.toBN(channelState.weiBalanceI)
                  },
                  signer: sender
                };
                _context9.next = 34;
                return this.createChannelStateUpdate(sigParams);

              case 34:
                sig = _context9.sent;
                _context9.next = 37;
                return this.fastCloseChannelHandler({
                  sig: sig,
                  channelId: channel.channelId
                });

              case 37:
                finalState = _context9.sent;

                if (finalState.sigI) {
                  _context9.next = 40;
                  break;
                }

                throw new ChannelCloseError(methodName, 601, "Hub did not countersign proposed update, channel could not be fast closed.");

              case 40:
                _context9.next = 42;
                return this.consensusCloseChannelContractHandler({
                  channelId: channel.channelId,
                  nonce: channelState.nonce + 1,
                  balanceA: {
                    tokenDeposit: Web3.utils.toBN(channelState.tokenBalanceA),
                    weiDeposit: Web3.utils.toBN(channelState.weiBalanceA)
                  },
                  balanceI: {
                    tokenDeposit: Web3.utils.toBN(channelState.tokenBalanceI),
                    weiDeposit: Web3.utils.toBN(channelState.weiBalanceI)
                  },
                  sigA: sig,
                  sigI: finalState.sigI,
                  sender: sender.toLowerCase()
                });

              case 42:
                response = _context9.sent;
                return _context9.abrupt("return", response.transactionHash);

              case 44:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function closeChannel() {
        return _ref17.apply(this, arguments);
      }

      return closeChannel;
    }()

    // ***************************************
    // ************* DISPUTE FNS *************
    // ***************************************

    /**
     * Withdraws bonded funds from channel after a channel it is challenge closed and the dispute timer has elapsed.
     *
     * @example
     * try {
     *   const success = await connext.closeChannel(channelId)
     * } catch (e) {
     *   if (e.statusCode === 601) {
     *      await connext.updateChannelState()
     *      // wait out challenge period
     *      await connext.withdraw()
     *   }
     * }
     *
     * @param {String} sender - (optional) the person sending the on chain transaction, defaults to accounts[0]
     * @returns {Promise} resolves to the transaction hash from calling byzantineCloseChannels
     */

  }, {
    key: "withdraw",
    value: function () {
      var _ref18 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
        var sender = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var methodName, isAddress, accounts, channel, results;
        return _regenerator2.default.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                methodName = "withdraw";
                isAddress = { presence: true, isAddress: true };

                if (!sender) {
                  _context10.next = 6;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context10.next = 10;
                break;

              case 6:
                _context10.next = 8;
                return this.web3.eth.getAccounts();

              case 8:
                accounts = _context10.sent;

                sender = accounts[0].toLowerCase();

              case 10:
                _context10.next = 12;
                return this.getChannelByPartyA(sender);

              case 12:
                channel = _context10.sent;
                _context10.next = 15;
                return this.byzantineCloseChannelContractHandler({
                  lcId: channel.channelId,
                  sender: sender
                });

              case 15:
                results = _context10.sent;
                return _context10.abrupt("return", results);

              case 17:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function withdraw() {
        return _ref18.apply(this, arguments);
      }

      return withdraw;
    }()

    /**
     * Verifies and cosigns the latest channel state update.
     *
     * @example
     * const { channelId } = await connext.getChannelIdByPartyA()
     * await connext.cosignLatestChannelUpdate(channelId)
     *
     * @param {String} channelId - channel id
     * @param {String} sender - (optional) the person who cosigning the update, defaults to accounts[0]
     * @returns {Promise} resolves to the cosigned channel state update
     */

  }, {
    key: "cosignLatestChannelUpdate",
    value: function () {
      var _ref19 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(channelId) {
        var sender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var methodName, isHexStrict, accounts, channel, latestState, result;
        return _regenerator2.default.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                methodName = "cosignLatestChannelUpdate";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");

                if (!sender) {
                  _context11.next = 7;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context11.next = 11;
                break;

              case 7:
                _context11.next = 9;
                return this.web3.eth.getAccounts();

              case 9:
                accounts = _context11.sent;

                sender = accounts[0].toLowerCase();

              case 11:
                _context11.next = 13;
                return this.getChannelById(channelId);

              case 13:
                channel = _context11.sent;

                if (!(channel == null)) {
                  _context11.next = 16;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel not found");

              case 16:
                if (!(channel.partyA !== sender.toLowerCase())) {
                  _context11.next = 18;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Incorrect signer detected");

              case 18:
                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.LCS_OPENED)) {
                  _context11.next = 20;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel is in invalid state");

              case 20:
                _context11.next = 22;
                return this.getLatestChannelState(lcId, ["sigI"]);

              case 22:
                latestState = _context11.sent;
                _context11.next = 25;
                return this.cosignChannelUpdate({
                  channelId: channelId,
                  nonce: latestState.nonce,
                  sender: sender
                });

              case 25:
                result = _context11.sent;
                return _context11.abrupt("return", result);

              case 27:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function cosignLatestChannelUpdate(_x18) {
        return _ref19.apply(this, arguments);
      }

      return cosignLatestChannelUpdate;
    }()

    /**
     * Verifies and cosigns the channel state update indicated by the provided nonce.
     *
     * @example
     * const { channelId } = await connext.getChannelIdByPartyA()
     * const nonce = 4
     * await connext.cosignLatestChannelUpdate({ channelId, nonce })
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - channel id
     * @param {Number} params.nonce - nonce of update you would like to cosign
     * @param {String} params.sender - (optional) the person who cosigning the update, defaults to accounts[0]
     * @returns {Promise} resolves to the cosigned ledger channel state update
     */

  }, {
    key: "cosignChannelUpdate",
    value: function () {
      var _ref21 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12(_ref20) {
        var channelId = _ref20.channelId,
            nonce = _ref20.nonce,
            _ref20$sender = _ref20.sender,
            sender = _ref20$sender === undefined ? null : _ref20$sender;
        var methodName, isHexStrict, isPositiveInt, accounts, channel, state, signer, sigA, response;
        return _regenerator2.default.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                methodName = "cosignChannelUpdate";
                isHexStrict = { presence: true, isHexStrict: true };
                isPositiveInt = { presence: true, isPositiveInt: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");

                if (!sender) {
                  _context12.next = 9;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context12.next = 13;
                break;

              case 9:
                _context12.next = 11;
                return this.web3.eth.getAccounts();

              case 11:
                accounts = _context12.sent;

                sender = accounts[0].toLowerCase();

              case 13:
                _context12.next = 15;
                return this.getChannelById(channelId);

              case 15:
                channel = _context12.sent;

                if (!(channel == null)) {
                  _context12.next = 18;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel not found");

              case 18:
                if (!(channel.partyA !== sender.toLowerCase())) {
                  _context12.next = 20;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Incorrect signer detected");

              case 20:
                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.LCS_OPENED)) {
                  _context12.next = 22;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel is in invalid state");

              case 22:
                if (!(nonce > channel.nonce)) {
                  _context12.next = 24;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid nonce detected");

              case 24:
                _context12.next = 26;
                return this.getChannelStateByNonce({ channelId: channelId, nonce: nonce });

              case 26:
                state = _context12.sent;


                // verify sigI
                signer = Connext.recoverSignerFromChannelStateUpdate({
                  sig: state.sigI,
                  isClose: state.isClose,
                  channelId: channelId,
                  nonce: nonce,
                  numOpenThread: state.numOpenThread,
                  threadRootHash: state.threadRootHash,
                  partyA: sender,
                  partyI: this.hubAddress,
                  weiBalanceA: Web3.utils.toBN(state.weiBalanceA),
                  weiBalanceI: Web3.utils.toBN(state.weiBalanceI),
                  tokenBalanceA: Web3.utils.toBN(state.tokenBalanceA),
                  tokenBalanceI: Web3.utils.toBN(state.tokenBalanceI)
                });

                if (!(signer.toLowerCase() !== this.hubAddress.toLowerCase())) {
                  _context12.next = 30;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid signature detected");

              case 30:

                state.signer = state.partyA;
                state.channelId = channelId;
                _context12.next = 34;
                return this.createChannelStateUpdate(state);

              case 34:
                sigA = _context12.sent;
                _context12.next = 37;
                return this.networking.post("channel/" + channelId + "/update/" + nonce + "/cosign", {
                  sig: sigA
                });

              case 37:
                response = _context12.sent;
                return _context12.abrupt("return", response.data);

              case 39:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function cosignChannelUpdate(_x19) {
        return _ref21.apply(this, arguments);
      }

      return cosignChannelUpdate;
    }()

    // ***************************************
    // *********** STATIC METHODS ************
    // ***************************************

    /**
     * Returns a new channel id that is a random hex string.
     *
     * @returns {String} a random 32 byte channel ID.
     */

  }, {
    key: "createChannelStateUpdate",


    // ***************************************
    // ********** SIGNATURE METHODS **********
    // ***************************************

    /**
     * Generates a signed channel state update.
     *
     * @param {Object} params - the method object
     * @param {Boolean} params.isClose - (optional) flag indicating whether or not this is closing state, defaults to false
     * @param {String} params.channelId - ID of the channel you are updating
     * @param {Number} params.nonce - the sequence of update
     * @param {Number} params.numOpenThread - the number of open threads associated with this channel
     * @param {String} params.threadRootHash - the root hash of the Merkle tree containing all initial states of the open threads
     * @param {String} params.partyA - ETH address of partyA in the channel
     * @param {String} params.partyI - (optional) ETH address of the hub, defaults to this.hubAddress
     * @param {Object} params.balanceA - updated balance of partyA
     * @param {BN} params.balanceA.weiDeposit - (optional) final wei balance of partyA in channel
     * @param {BN} params.balanceA.tokenDeposit - (optional) final token balance of partyA in channel
     * @param {Object} params.balanceI - final balance of hub in channel
     * @param {BN} params.balanceI.weiDeposit - (optional) final wei balance of hub in channel
     * @param {BN} params.balanceI.tokenDeposit - (optional) final token balance of hub in channel
     * @param {Boolean} params.unlockedAccountPresent - (optional) whether to use sign or personal sign, defaults to false if in prod and true if in dev
     * @param {String} params.signer - (optional) ETH address of person signing data, defaults to account[0]
     * @param {Object} params.hubBond - (optional) should be supplied if creating or closing a thread
     * @param {Object} params.deposit - (optional) should be supplied if creating a deposit into a channel
     * @returns {String} signature of signer on data provided
     */
    value: function () {
      var _ref23 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(_ref22) {
        var _ref22$isClose = _ref22.isClose,
            isClose = _ref22$isClose === undefined ? false : _ref22$isClose,
            channelId = _ref22.channelId,
            nonce = _ref22.nonce,
            numOpenThread = _ref22.numOpenThread,
            threadRootHash = _ref22.threadRootHash,
            partyA = _ref22.partyA,
            _ref22$partyI = _ref22.partyI,
            partyI = _ref22$partyI === undefined ? this.hubAddress : _ref22$partyI,
            balanceA = _ref22.balanceA,
            balanceI = _ref22.balanceI,
            _ref22$unlockedAccoun = _ref22.unlockedAccountPresent,
            unlockedAccountPresent = _ref22$unlockedAccoun === undefined ? process.env.DEV ? process.env.DEV : false : _ref22$unlockedAccoun,
            _ref22$signer = _ref22.signer,
            signer = _ref22$signer === undefined ? null : _ref22$signer,
            _ref22$hubBond = _ref22.hubBond,
            hubBond = _ref22$hubBond === undefined ? null : _ref22$hubBond,
            _ref22$deposit = _ref22.deposit,
            deposit = _ref22$deposit === undefined ? null : _ref22$deposit;
        var methodName, isHexStrict, isHex, isBN, isAddress, isPositiveInt, isBool, isValidDepositObject, accounts, emptyRootHash, channel, proposedWeiBalance, proposedTokenBalance, isOpeningVc, ethChannelBalance, tokenChannelBalance, hash, sig;
        return _regenerator2.default.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                methodName = "createChannelStateUpdate";
                // validate
                // validatorOpts

                isHexStrict = { presence: true, isHexStrict: true };
                isHex = { presence: true, isHex: true };
                isBN = { presence: true, isBN: true };
                isAddress = { presence: true, isAddress: true };
                isPositiveInt = { presence: true, isPositiveInt: true };
                isBool = { presence: true, isBool: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };


                Connext.validatorsResponseToError(validate.single(isClose, isBool), methodName, "isClose");
                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                Connext.validatorsResponseToError(validate.single(numOpenThread, isPositiveInt), methodName, "numOpenThread");
                Connext.validatorsResponseToError(validate.single(threadRootHash, isHex), methodName, "threadRootHash");
                Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
                Connext.validatorsResponseToError(validate.single(partyI, isAddress), methodName, "partyI");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceI, isValidDepositObject), methodName, "balanceI");
                if (hubBond) {
                  Connext.validatorsResponseToError(validate.single(hubBond, isValidDepositObject), methodName, "hubBond");
                  hubBond.tokenDeposit = hubBond.tokenDeposit ? hubBond.tokenDeposit : Web3.utils.toBN("0");
                  hubBond.weiDeposit = hubBond.weiDeposit ? hubBond.weiDeposit : Web3.utils.toBN("0");
                } else {
                  // set to zero
                  hubBond = {
                    weiDeposit: Web3.utils.toBN("0"),
                    tokenDeposit: Web3.utils.toBN("0")
                  };
                }

                if (deposit) {
                  Connext.validatorsResponseToError(validate.single(deposit, isValidDepositObject), methodName, "deposit");
                  deposit.weiDeposit = deposit.weiDeposit ? deposit.weiDeposit : Web3.utils.toBN("0");
                  deposit.tokenDeposit = deposit.tokenDeposit ? deposit.tokenDeposit : Web3.utils.toBN("0");
                } else {
                  deposit = {
                    weiDeposit: Web3.utils.toBN("0"),
                    tokenDeposit: Web3.utils.toBN("0")
                  };
                }

                if (!signer) {
                  _context13.next = 23;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(signer, isAddress), methodName, "signer");
                _context13.next = 27;
                break;

              case 23:
                _context13.next = 25;
                return this.web3.eth.getAccounts();

              case 25:
                accounts = _context13.sent;

                signer = accounts[0].toLowerCase();

              case 27:
                if (!(signer.toLowerCase() !== partyA.toLowerCase() && signer.toLowerCase() !== partyI.toLowerCase())) {
                  _context13.next = 29;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid signer detected");

              case 29:

                // validate update
                emptyRootHash = Connext.generateThreadRootHash({
                  threadInitialStates: []
                });
                _context13.next = 32;
                return this.getChannelById(channelId);

              case 32:
                channel = _context13.sent;
                proposedWeiBalance = void 0, proposedTokenBalance = void 0;

                if (!(channel == null)) {
                  _context13.next = 51;
                  break;
                }

                // set initial balances to 0 if thread does not exist
                channel.weiBalanceA = "0";
                channel.weiBalanceB = "0";
                channel.tokenBalanceA = "0";
                channel.tokenBalanceB = "0";
                // generating opening cert

                if (!(nonce !== 0)) {
                  _context13.next = 41;
                  break;
                }

                throw new ChannelOpenError(methodName, "Invalid nonce detected");

              case 41:
                if (!(numOpenThread !== 0)) {
                  _context13.next = 43;
                  break;
                }

                throw new ChannelOpenError(methodName, "Invalid numOpenThread detected");

              case 43:
                if (!(threadRootHash !== emptyRootHash)) {
                  _context13.next = 45;
                  break;
                }

                throw new ChannelOpenError(methodName, "Invalid threadRootHash detected");

              case 45:
                if (!(partyA === partyI)) {
                  _context13.next = 47;
                  break;
                }

                throw new ChannelOpenError(methodName, "Cannot open channel with yourself");

              case 47:
                if (balanceA.weiDeposit && balanceI.weiDeposit) {
                  // channel includes ETH
                  proposedWeiBalance = balanceA.weiDeposit.add(balanceI.weiDeposit);
                }
                if (balanceA.tokenDeposit && balanceI.tokenDeposit) {
                  // channel includes token
                  proposedTokenBalance = balanceA.tokenDeposit.add(balanceI.tokenDeposit);
                }
                _context13.next = 68;
                break;

              case 51:
                if (!(CHANNEL_STATES[channel.status] === 3)) {
                  _context13.next = 53;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Channel is in invalid state to accept updates");

              case 53:
                if (!(nonce < channel.nonce)) {
                  _context13.next = 55;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid nonce");

              case 55:
                if (!(Math.abs(Number(numOpenThread) - Number(channel.numOpenThread)) !== 1 && Math.abs(Number(numOpenThread) - Number(channel.numOpenThread)) !== 0)) {
                  _context13.next = 57;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid number of numOpenThread proposed");

              case 57:
                if (!(partyA.toLowerCase() !== channel.partyA.toLowerCase() || partyI.toLowerCase() !== channel.partyI.toLowerCase())) {
                  _context13.next = 59;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid channel parties");

              case 59:
                if (balanceA.weiDeposit && balanceI.weiDeposit) {
                  // channel includes ETH
                  proposedWeiBalance = balanceA.weiDeposit.add(balanceI.weiDeposit);
                }
                if (balanceA.tokenDeposit && balanceI.tokenDeposit) {
                  // channel includes token
                  proposedTokenBalance = balanceA.tokenDeposit.add(balanceI.tokenDeposit);
                }
                // no change in total balance
                // add ledger channel balances of both parties from previously, subctract new balance of vc being opened
                isOpeningVc = numOpenThread - channel.numOpenThread === 1;
                // verify updates dont change channel balance

                ethChannelBalance = isOpeningVc ? Web3.utils.toBN(channel.weiBalanceA).add(Web3.utils.toBN(channel.weiBalanceI)).add(deposit.weiDeposit).sub(hubBond.weiDeposit) : Web3.utils.toBN(channel.weiBalanceA).add(Web3.utils.toBN(channel.weiBalanceI)).add(deposit.weiDeposit).add(hubBond.weiDeposit);
                tokenChannelBalance = isOpeningVc ? Web3.utils.toBN(channel.tokenBalanceA).add(Web3.utils.toBN(channel.tokenBalanceI)).add(deposit.tokenDeposit).sub(hubBond.tokenDeposit) : Web3.utils.toBN(channel.tokenBalanceA).add(Web3.utils.toBN(channel.tokenBalanceI)).add(deposit.tokenDeposit).add(hubBond.tokenDeposit);

                if (!(proposedWeiBalance && !proposedWeiBalance.eq(ethChannelBalance))) {
                  _context13.next = 66;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid ETH balance proposed");

              case 66:
                if (!(proposedTokenBalance && !proposedTokenBalance.eq(tokenChannelBalance))) {
                  _context13.next = 68;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Invalid token balance proposed");

              case 68:

                console.log("signing:", JSON.stringify({
                  isClose: isClose,
                  channelId: channelId,
                  nonce: nonce,
                  numOpenThread: numOpenThread,
                  threadRootHash: threadRootHash,
                  partyA: partyA,
                  partyI: partyI,
                  weiBalanceA: proposedWeiBalance ? balanceA.weiDeposit.toString() : "0",
                  weiBalanceI: proposedWeiBalance ? balanceI.weiDeposit.toString() : "0",
                  tokenBalanceA: proposedTokenBalance ? balanceA.tokenDeposit.toString() : "0",
                  tokenBalanceI: proposedTokenBalance ? balanceI.tokenDeposit.toString() : "0"
                }));
                // generate sig
                hash = Connext.createChannelStateUpdateFingerprint({
                  channelId: channelId,
                  isClose: isClose,
                  nonce: nonce,
                  numOpenThread: numOpenThread,
                  threadRootHash: threadRootHash,
                  partyA: partyA,
                  partyI: partyI,
                  weiBalanceA: proposedWeiBalance ? balanceA.weiDeposit : Web3.utils.toBN("0"),
                  weiBalanceI: proposedWeiBalance ? balanceI.weiDeposit : Web3.utils.toBN("0"),
                  tokenBalanceA: proposedTokenBalance ? balanceA.tokenDeposit : Web3.utils.toBN("0"),
                  tokenBalanceI: proposedTokenBalance ? balanceI.tokenDeposit : Web3.utils.toBN("0")
                });
                sig = void 0;

                if (!unlockedAccountPresent) {
                  _context13.next = 77;
                  break;
                }

                _context13.next = 74;
                return this.web3.eth.sign(hash, signer);

              case 74:
                sig = _context13.sent;
                _context13.next = 80;
                break;

              case 77:
                _context13.next = 79;
                return this.web3.eth.personal.sign(hash, signer);

              case 79:
                sig = _context13.sent;

              case 80:
                console.log("sig:", sig);
                return _context13.abrupt("return", sig);

              case 82:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function createChannelStateUpdate(_x20) {
        return _ref23.apply(this, arguments);
      }

      return createChannelStateUpdate;
    }()

    /**
     * Creates a signed thread state update
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - ID of the thread you are updatign
     * @param {Number} params.nonce - the sequence of the state update
     * @param {String} params.partyA - ETH address of partyA
     * @param {String} params.partyB - ETH address of partyB
     * @param {Number} params.balanceA - updated balance of partyA
     * @param {BN} params.balanceA.weiDeposit - updated party A wei balance
     * @param {BN} params.balanceA.tokenDeposit - updated partyA token balance
     * @param {Object} params.balanceB - updated partB balance object
     * @param {BN} params.balanceB.weiDeposit - updated partyB wei balance
     * @param {BN} params.balanceB.tokenDeposit - updated partyB token balance
     * @param {Boolean} params.unlockedAccountPresent - (optional) whether to use sign or personal sign, defaults to false if in prod and true if in dev
     *
     * @param {String} params.signer - (optional) ETH address of person signing data, defaults to account[0]
     * @returns {String} signature of signer on data provided
     */

  }, {
    key: "createThreadStateUpdate",
    value: function () {
      var _ref25 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14(_ref24) {
        var channelId = _ref24.channelId,
            nonce = _ref24.nonce,
            partyA = _ref24.partyA,
            partyB = _ref24.partyB,
            balanceA = _ref24.balanceA,
            balanceB = _ref24.balanceB,
            updateType = _ref24.updateType,
            _ref24$unlockedAccoun = _ref24.unlockedAccountPresent,
            unlockedAccountPresent = _ref24$unlockedAccoun === undefined ? process.env.DEV ? process.env.DEV : false : _ref24$unlockedAccoun,
            _ref24$signer = _ref24.signer,
            signer = _ref24$signer === undefined ? null : _ref24$signer;
        var methodName, isHexStrict, isValidDepositObject, isAddress, isPositiveInt, subchanA, thread, proposedWeiBalance, proposedTokenBalance, threadEthBalance, threadTokenBalance, accounts, state, hash, sig;
        return _regenerator2.default.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                // validate
                methodName = "createThreadStateUpdate";
                // validate
                // validatorOpts'

                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isAddress = { presence: true, isAddress: true };
                isPositiveInt = { presence: true, isPositiveInt: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
                Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceB, isValidDepositObject), methodName, "balanceB");
                // verify subchannel
                _context14.next = 13;
                return this.getChannelByPartyA(partyA);

              case 13:
                subchanA = _context14.sent;
                _context14.next = 16;
                return this.getThreadById(channelId);

              case 16:
                thread = _context14.sent;
                proposedWeiBalance = void 0, proposedTokenBalance = void 0;

                if (!(thread === null)) {
                  _context14.next = 37;
                  break;
                }

                if (!(nonce !== 0)) {
                  _context14.next = 21;
                  break;
                }

                throw new ThreadOpenError(methodName, "Invalid nonce detected");

              case 21:
                if (!(balanceB.weiDeposit && !balanceB.weiDeposit.isZero())) {
                  _context14.next = 23;
                  break;
                }

                throw new ThreadOpenError(methodName, "Invalid initial ETH balanceB detected");

              case 23:
                if (!(balanceB.tokenDeposit && !balanceB.tokenDeposit.isZero())) {
                  _context14.next = 25;
                  break;
                }

                throw new ThreadOpenError(methodName, "Invalid initial token balanceB detected");

              case 25:
                if (!(partyA.toLowerCase() === partyB.toLowerCase())) {
                  _context14.next = 27;
                  break;
                }

                throw new ThreadOpenError(methodName, "Cannot open thread with yourself");

              case 27:
                if (!balanceA.weiDeposit) {
                  _context14.next = 31;
                  break;
                }

                if (!Web3.utils.toBN(subchanA.weiBalanceA).lt(balanceA.weiDeposit)) {
                  _context14.next = 30;
                  break;
                }

                throw new ThreadOpenError(methodName, "Insufficient ETH channel balance detected");

              case 30:
                proposedWeiBalance = balanceA.weiDeposit;

              case 31:
                if (!balanceA.tokenDeposit) {
                  _context14.next = 35;
                  break;
                }

                if (!Web3.utils.toBN(subchanA.tokenBalanceA).lt(balanceA.tokenDeposit)) {
                  _context14.next = 34;
                  break;
                }

                throw new ThreadOpenError(methodName, "Insufficient ETH channel balance detected");

              case 34:
                proposedTokenBalance = balanceA.tokenDeposit;

              case 35:
                _context14.next = 68;
                break;

              case 37:
                if (!(THREAD_STATES[thread.status] === 3)) {
                  _context14.next = 39;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread is in invalid state");

              case 39:
                if (!(nonce < thread.nonce + 1 && nonce !== 0)) {
                  _context14.next = 41;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Invalid nonce");

              case 41:
                if (!(partyA.toLowerCase() !== thread.partyA || partyB.toLowerCase() !== thread.partyB)) {
                  _context14.next = 43;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Invalid parties detected");

              case 43:
                // verify updates dont change channel balance
                threadEthBalance = Web3.utils.toBN(thread.weiBalanceA).add(Web3.utils.toBN(thread.weiBalanceB));
                threadTokenBalance = Web3.utils.toBN(thread.tokenBalanceA).add(Web3.utils.toBN(thread.tokenBalanceB));
                _context14.t0 = CHANNEL_TYPES[updateType];
                _context14.next = _context14.t0 === CHANNEL_TYPES.ETH ? 48 : _context14.t0 === CHANNEL_TYPES.TOKEN ? 52 : _context14.t0 === CHANNEL_TYPES.TOKEN_ETH ? 56 : 63;
                break;

              case 48:
                if (!balanceB.weiDeposit.lt(Web3.utils.toBN(thread.weiBalanceB))) {
                  _context14.next = 50;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB ETH balance");

              case 50:
                proposedWeiBalance = Web3.utils.toBN(balanceA.weiDeposit).add(balanceB.weiDeposit); // proposed balance
                return _context14.abrupt("break", 64);

              case 52:
                if (!balanceB.tokenDeposit.lt(Web3.utils.toBN(thread.tokenBalanceB))) {
                  _context14.next = 54;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB token balance");

              case 54:
                proposedTokenBalance = Web3.utils.toBN(balanceA.tokenDeposit).add(balanceB.tokenDeposit);
                return _context14.abrupt("break", 64);

              case 56:
                if (!balanceB.weiDeposit.lt(Web3.utils.toBN(thread.weiBalanceB))) {
                  _context14.next = 58;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB ETH balance");

              case 58:
                if (!balanceB.tokenDeposit.lt(Web3.utils.toBN(thread.tokenBalanceB))) {
                  _context14.next = 60;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread updates can only increase partyB token balance");

              case 60:
                proposedWeiBalance = Web3.utils.toBN(balanceA.weiDeposit).add(balanceB.weiDeposit);
                proposedTokenBalance = Web3.utils.toBN(balanceA.tokenDeposit).add(balanceB.tokenDeposit);
                return _context14.abrupt("break", 64);

              case 63:
                throw new ThreadUpdateError(methodName, "Invalid thread update type.");

              case 64:
                if (!(proposedWeiBalance && !proposedWeiBalance.eq(threadEthBalance))) {
                  _context14.next = 66;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread ETH balance cannot change");

              case 66:
                if (!(proposedTokenBalance && !proposedTokenBalance.eq(threadTokenBalance))) {
                  _context14.next = 68;
                  break;
                }

                throw new ThreadUpdateError(methodName, "Thread token balance cannot change");

              case 68:
                _context14.next = 70;
                return this.web3.eth.getAccounts();

              case 70:
                accounts = _context14.sent;

                // generate and sign hash
                state = {
                  channelId: channelId,
                  nonce: nonce,
                  partyA: partyA,
                  partyB: partyB,
                  // if balance change proposed, use balance
                  // else use thread balance if thread exists (will be null on open)
                  // else use 0
                  weiBalanceA: proposedWeiBalance ? balanceA.weiDeposit : thread ? Web3.utils.toBN(thread.weiBalanceA) : Web3.utils.toBN("0"),
                  weiBalanceB: proposedWeiBalance ? balanceB.weiDeposit : thread ? Web3.utils.toBN(thread.weiBalanceB) : Web3.utils.toBN("0"),
                  tokenBalanceA: proposedTokenBalance ? balanceA.tokenDeposit : thread ? Web3.utils.toBN(thread.tokenBalanceA) : Web3.utils.toBN("0"),
                  tokenBalanceB: proposedTokenBalance ? balanceB.tokenDeposit : thread ? Web3.utils.toBN(thread.tokenBalanceB) : Web3.utils.toBN("0"),
                  weiBond: proposedWeiBalance ? proposedWeiBalance : Web3.utils.toBN("0"),
                  tokenBond: proposedTokenBalance ? proposedTokenBalance : Web3.utils.toBN("0")
                };
                hash = Connext.createThreadStateUpdateFingerprint(state);

                console.log("signing:", JSON.stringify(state));
                sig = void 0;

                if (!(signer && unlockedAccountPresent)) {
                  _context14.next = 81;
                  break;
                }

                _context14.next = 78;
                return this.web3.eth.sign(hash, signer);

              case 78:
                sig = _context14.sent;
                _context14.next = 96;
                break;

              case 81:
                if (!signer) {
                  _context14.next = 87;
                  break;
                }

                _context14.next = 84;
                return this.web3.eth.personal.sign(hash, signer);

              case 84:
                sig = _context14.sent;
                _context14.next = 96;
                break;

              case 87:
                if (!unlockedAccountPresent) {
                  _context14.next = 93;
                  break;
                }

                _context14.next = 90;
                return this.web3.eth.sign(hash, accounts[0]);

              case 90:
                sig = _context14.sent;
                _context14.next = 96;
                break;

              case 93:
                _context14.next = 95;
                return this.web3.eth.personal.sign(hash, accounts[0]);

              case 95:
                sig = _context14.sent;

              case 96:
                console.log("sig:", sig);
                return _context14.abrupt("return", sig);

              case 98:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function createThreadStateUpdate(_x21) {
        return _ref25.apply(this, arguments);
      }

      return createThreadStateUpdate;
    }()

    /**
     * Creates a hash of the thread initial states provided.
     *
     * @example
     * const threadInitialStates = await connext.getThreadInitialStates(channelId)
     * const threadRootHash = Connext.generateThreadRootHash({ threadInitialStates })
     *
     * @param {Object[]} threadInitialStates - an array of initial thread states.
     */

  }, {
    key: "createChannelContractHandler",


    // HELPER FUNCTIONS

    // ***************************************
    // ******** CONTRACT HANDLERS ************
    // ***************************************

    /**
     * Calls createChannel on the Channel Manager contract.
     *
     * @example
     * // wallet must approve token transfer to contract
     * // before creating a TOKEN or ETH-TOKEN channel
     * const channelId = Connext.getNewChannelId()
     * const initialDeposits = {
     *    weiDeposit: Web3.utils.toBN('100'),
     *    tokenDeposit: Web3.utils.toBN('100'),
     * }
     * const challenge = 3600
     * const tokenAddress = "0xaa..."
     * await connext.crateChannelContractHandler({ initialDeposits, channelId, challenge, tokenAddress })
     *
     * @param {Object} params - the method object
     * @param {String} params.hubAddress - (optional) defaults to the address supplied on init
     * @param {String} params.channelId - channelId, should be generated using Connext static functions
     * @param {Object} params.initialDeposits - ,
     * @param {Number} params.challenge - challenge period in seconds
     * @param {String} params.tokenAddress - (optional) tokenAddress for the tokens you would like to bond in the channel. Do not supply for an ETH only channel
     * @param {String} params.sender - (optional) the account that will create the channel (channel.partyA). Defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */
    value: function () {
      var _ref27 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(_ref26) {
        var _ref26$hubAddress = _ref26.hubAddress,
            hubAddress = _ref26$hubAddress === undefined ? this.hubAddress : _ref26$hubAddress,
            channelId = _ref26.channelId,
            initialDeposits = _ref26.initialDeposits,
            challenge = _ref26.challenge,
            channelType = _ref26.channelType,
            _ref26$tokenAddress = _ref26.tokenAddress,
            tokenAddress = _ref26$tokenAddress === undefined ? null : _ref26$tokenAddress,
            _ref26$sender = _ref26.sender,
            sender = _ref26$sender === undefined ? null : _ref26$sender;
        var methodName, isHexStrict, isAddress, isPositiveInt, isValidDepositObject, accounts, result, token, tokenApproval;
        return _regenerator2.default.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                methodName = "createChannelContractHandler";
                // validate

                isHexStrict = { presence: true, isHexStrict: true };
                isAddress = { presence: true, isAddress: true };
                isPositiveInt = { presence: true, isPositiveInt: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };

                Connext.validatorsResponseToError(validate.single(hubAddress, isAddress), methodName, "hubAddress");
                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(initialDeposits, isValidDepositObject), methodName, "initialDeposits");
                Connext.validatorsResponseToError(validate.single(challenge, isPositiveInt), methodName, "challenge");
                if (tokenAddress) {
                  Connext.validatorsResponseToError(validate.single(tokenAddress, isAddress), methodName, "tokenAddress");
                }

                if (!sender) {
                  _context15.next = 14;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context15.next = 18;
                break;

              case 14:
                _context15.next = 16;
                return this.web3.eth.getAccounts();

              case 16:
                accounts = _context15.sent;

                sender = accounts[0].toLowerCase();

              case 18:
                if (!(sender === hubAddress)) {
                  _context15.next = 20;
                  break;
                }

                throw new ChannelOpenError(methodName, "Cannot open a channel with yourself");

              case 20:
                result = void 0, token = void 0, tokenApproval = void 0;
                _context15.t0 = CHANNEL_TYPES[channelType];
                _context15.next = _context15.t0 === CHANNEL_TYPES.ETH ? 24 : _context15.t0 === CHANNEL_TYPES.TOKEN ? 29 : _context15.t0 === CHANNEL_TYPES.TOKEN_ETH ? 41 : 53;
                break;

              case 24:
                // ETH
                tokenAddress = "0x0";
                _context15.next = 27;
                return this.channelManagerInstance.methods.createChannel(channelId, hubAddress, challenge, tokenAddress, [initialDeposits.weiDeposit, Web3.utils.toBN("0")]).send({
                  from: sender,
                  value: initialDeposits.weiDeposit,
                  gas: 750000
                });

              case 27:
                result = _context15.sent;
                return _context15.abrupt("break", 54);

              case 29:
                // TOKEN
                // approve token transfer
                token = new this.web3.eth.Contract(tokenAbi, tokenAddress);
                _context15.next = 32;
                return token.methods.approve(hubAddress, initialDeposits.tokenDeposit).send({
                  from: sender,
                  gas: 750000
                });

              case 32:
                tokenApproval = _context15.sent;

                if (!tokenApproval) {
                  _context15.next = 39;
                  break;
                }

                _context15.next = 36;
                return this.channelManagerInstance.methods.createChannel(channelId, hubAddress, challenge, tokenAddress, [Web3.utils.toBN("0"), initialDeposits.tokenDeposit]).send({
                  from: sender,
                  gas: 750000
                });

              case 36:
                result = _context15.sent;
                _context15.next = 40;
                break;

              case 39:
                throw new ChannelOpenError(methodName, "Token transfer failed.");

              case 40:
                return _context15.abrupt("break", 54);

              case 41:
                // ETH/TOKEN
                // approve token transfer
                token = new this.web3.eth.Contract(tokenAbi, tokenAddress);
                _context15.next = 44;
                return token.approve.call(hubAddress, initialDeposits.tokenDeposit, {
                  from: sender
                });

              case 44:
                tokenApproval = _context15.sent;

                if (!tokenApproval) {
                  _context15.next = 51;
                  break;
                }

                _context15.next = 48;
                return this.channelManagerInstance.methods.createChannel(channelId, hubAddress, challenge, tokenAddress, [initialDeposits.weiDeposit, initialDeposits.tokenDeposit]).send({
                  from: sender,
                  value: initialDeposits.weiDeposit,
                  gas: 750000
                });

              case 48:
                result = _context15.sent;
                _context15.next = 52;
                break;

              case 51:
                throw new ChannelOpenError(methodName, "Token transfer failed.");

              case 52:
                return _context15.abrupt("break", 54);

              case 53:
                throw new ChannelOpenError(methodName, "Invalid channel type");

              case 54:
                if (result.transactionHash) {
                  _context15.next = 56;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 56:
                if (result.blockNumber) {
                  _context15.next = 58;
                  break;
                }

                throw new ContractError(methodName, 302, result.transactionHash, "Transaction failed");

              case 58:
                return _context15.abrupt("return", result);

              case 59:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function createChannelContractHandler(_x22) {
        return _ref27.apply(this, arguments);
      }

      return createChannelContractHandler;
    }()

    /**
     * Users should use this to recover bonded funds if the hub fails to join the ledger channel within the challenge window.
     *
     * @param {String} channelId - channel id the hub did not join
     * @param {String} sender - (optional) who is calling the transaction (defaults to accounts[0]). Should be partyA in unjoined channel
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "channelOpenTimeoutContractHandler",
    value: function () {
      var _ref28 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee16(channelId) {
        var sender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var methodName, isAddress, isHexStrict, accounts, channel, result;
        return _regenerator2.default.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                methodName = "ChannelOpenTimeoutContractHandler";
                // validate

                isAddress = { presence: true, isAddress: true };
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");

                if (!sender) {
                  _context16.next = 8;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context16.next = 12;
                break;

              case 8:
                _context16.next = 10;
                return this.web3.eth.getAccounts();

              case 10:
                accounts = _context16.sent;

                sender = accounts[0].toLowerCase();

              case 12:
                _context16.next = 14;
                return this.getChannelById(channelId);

              case 14:
                channel = _context16.sent;

                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.LCS_OPENING)) {
                  _context16.next = 17;
                  break;
                }

                throw new ChannelOpenError(methodName, "Channel is in incorrect state");

              case 17:
                if (!(channel.partyA.toLowerCase() !== sender.toLowerCase())) {
                  _context16.next = 19;
                  break;
                }

                throw new ContractError(methodName, "Caller must be partyA in ledger channel");

              case 19:
                _context16.next = 21;
                return this.channelManagerInstance.methods.channelOpenTimeout(channelId).send({
                  from: sender,
                  gas: 470000
                });

              case 21:
                result = _context16.sent;

                if (result.transactionHash) {
                  _context16.next = 24;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 24:
                if (result.blockNumber) {
                  _context16.next = 26;
                  break;
                }

                throw new ContractError(methodName, 302, result.transactionHash, "Transaction failed");

              case 26:
                return _context16.abrupt("return", result);

              case 27:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function channelOpenTimeoutContractHandler(_x24) {
        return _ref28.apply(this, arguments);
      }

      return channelOpenTimeoutContractHandler;
    }()

    /**
     * Calls the contracts "deposit" method to deposit into an open channel. Wallet should approve the transfer to the contract of any deposited tokens before calling this method.
     *
     * You can deposit wei or tokens, but should call deposit separately to deposit both into a channel.
     *
     * @param {Object} params - the method object
     * @param {Object} params.deposits - the channel deposits
     * @param {BN} params.deposits.weiDeposit - (optional) wei deposit into channel
     * @param {BN} params.deposits.tokenDeposit - (optional) token deopsit into channel
     * @param {String} params.sender - (optional) the sender of the deposit. Defaults to accounts[0]
     * @param {String} params.recipient - (optional) the recipient of the deposit. Defaults to sender or accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "depositContractHandler",
    value: function () {
      var _ref30 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee17(_ref29) {
        var channelId = _ref29.channelId,
            deposits = _ref29.deposits,
            _ref29$sender = _ref29.sender,
            sender = _ref29$sender === undefined ? null : _ref29$sender,
            _ref29$recipient = _ref29.recipient,
            recipient = _ref29$recipient === undefined ? sender : _ref29$recipient;
        var methodName, isHexStrict, isValidDepositObject, isAddress, accounts, channel, weiDeposit, tokenDeposit, depositType, result;
        return _regenerator2.default.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                methodName = "depositContractHandler";
                // validate

                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(deposits, isValidDepositObject), methodName, "deposits");
                _context17.next = 8;
                return this.web3.eth.getAccounts();

              case 8:
                accounts = _context17.sent;

                if (sender) {
                  Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                } else {
                  sender = accounts[0].toLowerCase();
                }
                if (recipient) {
                  Connext.validatorsResponseToError(validate.single(recipient, isAddress), methodName, "recipient");
                } else {
                  // unspecified, defaults to active account
                  recipient = sender;
                }

                // verify requires --> already checked in deposit() fn, necessary?
                _context17.next = 13;
                return this.getChannelById(channelId);

              case 13:
                channel = _context17.sent;

                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.LCS_OPENED)) {
                  _context17.next = 16;
                  break;
                }

                throw new ContractError(methodName, "Channel is not open");

              case 16:
                if (!(recipient.toLowerCase() !== channel.partyA.toLowerCase() && recipient.toLowerCase() !== channel.partyI.toLowerCase())) {
                  _context17.next = 18;
                  break;
                }

                throw new ContractError(methodName, "Recipient is not a member of the ledger channel");

              case 18:

                // determine deposit type
                weiDeposit = deposits.weiDeposit, tokenDeposit = deposits.tokenDeposit;
                depositType = void 0;

                if (weiDeposit && tokenDeposit) {
                  // token and eth
                  depositType = Object.keys(CHANNEL_TYPES)[2];
                } else if (tokenDeposit) {
                  depositType = Object.keys(CHANNEL_TYPES)[1];
                } else if (weiDeposit) {
                  depositType = Object.keys(CHANNEL_TYPES)[0];
                }

                result = void 0;
                _context17.t0 = CHANNEL_TYPES[depositType];
                _context17.next = _context17.t0 === CHANNEL_TYPES.ETH ? 25 : _context17.t0 === CHANNEL_TYPES.TOKEN ? 29 : 33;
                break;

              case 25:
                _context17.next = 27;
                return this.channelManagerInstance.methods.deposit(channelId, // PARAM NOT IN CONTRACT YET, SHOULD BE
                recipient, deposits.weiDeposit, false).send({
                  from: sender,
                  value: deposits.weiDeposit,
                  gas: 1000000
                });

              case 27:
                result = _context17.sent;
                return _context17.abrupt("break", 34);

              case 29:
                _context17.next = 31;
                return this.channelManagerInstance.methods.deposit(channelId, // PARAM NOT IN CONTRACT YET, SHOULD BE
                recipient, deposits.tokenDeposit, false).send({
                  from: sender,
                  gas: 1000000
                });

              case 31:
                result = _context17.sent;
                return _context17.abrupt("break", 34);

              case 33:
                throw new ChannelUpdateError(methodName, "Invalid deposit type detected");

              case 34:
                if (result.transactionHash) {
                  _context17.next = 36;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 36:
                if (result.blockNumber) {
                  _context17.next = 38;
                  break;
                }

                throw new ContractError(methodName, 302, result.transactionHash, "Transaction failed");

              case 38:
                return _context17.abrupt("return", result);

              case 39:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function depositContractHandler(_x25) {
        return _ref30.apply(this, arguments);
      }

      return depositContractHandler;
    }()

    /**
     * Calls consensusCloseChannel on the ChannelManager contract.
     *
     * @example
     * // generate final state sigParams
     * const sig = await connext.createChannelStateUpdate(sigParams);
     * const { sigI } = await connext.fastCloseChannelHandler({
     *   sig,
     *   channelId: channel.channelId
     * });
     * await connext.conensusCloseChannelContractHandler({
     *   channelId: sigParams.channelId,
     *   nonce: sigParams.nonce,
     *   balanceA: sigParams.balanceA,
     *   balanceI: sigParams.balanceI,
     *   sigA,
     *   sigI
     * })
     *
     * @param {Object} params - the method object
     * @param {Number} params.nonce - the closing channel nonce
     * @param {Object} params.balanceA - the closing partyA balance
     * @param {BN} params.balanceA.weiDeposit - (optional) final wei balance of partyA in channel
     * @param {BN} params.balanceA.tokenDeposit - (optional) final token balance of partyA in channel
     * @param {Object} params.balanceI - final balance of hub in channel
     * @param {BN} params.balanceI.weiDeposit - (optional) final wei balance of hub in channel
     * @param {BN} params.balanceI.tokenDeposit - (optional) final token balance of hub in channel
     * @param {String} params.sigI - the hub's closing signature with the fast close flag
     * @param {String} params.sigA - partyA's closing signature with the fast close flag
     * @param {String} params.sender - (optional) the sender of the contract call, defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "consensusCloseChannelContractHandler",
    value: function () {
      var _ref32 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee18(_ref31) {
        var channelId = _ref31.channelId,
            nonce = _ref31.nonce,
            balanceA = _ref31.balanceA,
            balanceI = _ref31.balanceI,
            sigA = _ref31.sigA,
            sigI = _ref31.sigI,
            _ref31$sender = _ref31.sender,
            sender = _ref31$sender === undefined ? null : _ref31$sender;
        var methodName, isHexStrict, isPositiveInt, isValidDepositObject, isHex, isAddress, accounts, emptyRootHash, state, signer, result;
        return _regenerator2.default.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                methodName = "consensusCloseChannelContractHandler";
                // validate

                isHexStrict = { presence: true, isHexStrict: true };
                isPositiveInt = { presence: true, isPositiveInt: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isHex = { presence: true, isHex: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceI, isValidDepositObject), methodName, "balanceI");
                Connext.validatorsResponseToError(validate.single(sigA, isHex), methodName, "sigA");
                Connext.validatorsResponseToError(validate.single(sigI, isHex), methodName, "sigI");

                if (!sender) {
                  _context18.next = 16;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context18.next = 20;
                break;

              case 16:
                _context18.next = 18;
                return this.web3.eth.getAccounts();

              case 18:
                accounts = _context18.sent;

                sender = accounts[0].toLowerCase();

              case 20:
                // verify sigs
                emptyRootHash = Connext.generateThreadRootHash({
                  threadInitialStates: []
                });
                state = {
                  sig: sigI,
                  isClose: true,
                  channelId: channelId,
                  nonce: nonce,
                  numOpenThread: 0,
                  threadRootHash: emptyRootHash,
                  partyA: sender,
                  partyI: this.hubAddress,
                  weiBalanceA: balanceA.weiDeposit ? balanceA.weiDeposit : Web3.utils.toBN("0"),
                  weiBalanceI: balanceI.weiDeposit ? balanceI.weiDeposit : Web3.utils.toBN("0"),
                  tokenBalanceA: balanceA.tokenDeposit ? balanceA.tokenDeposit : Web3.utils.toBN("0"),
                  tokenBalanceI: balanceI.tokenDeposit ? balanceI.tokenDeposit : Web3.utils.toBN("0")
                };
                signer = Connext.recoverSignerFromChannelStateUpdate(state);

                if (!(signer.toLowerCase() !== this.hubAddress.toLowerCase())) {
                  _context18.next = 25;
                  break;
                }

                throw new ChannelCloseError(methodName, "Hub did not sign closing update");

              case 25:
                state.sig = sigA;
                signer = Connext.recoverSignerFromChannelStateUpdate(state);

                if (!(signer.toLowerCase() !== sender.toLowerCase())) {
                  _context18.next = 29;
                  break;
                }

                throw new ChannelCloseError(methodName, "PartyA did not sign closing update");

              case 29:
                _context18.next = 31;
                return this.channelManagerInstance.methods.consensusCloseChannel(channelId, nonce, [state.weiBalanceA, state.weiBalanceI, state.tokenBalanceA, state.tokenBalanceI], sigA, sigI).send({
                  from: sender,
                  gas: 1000000
                });

              case 31:
                result = _context18.sent;

                if (result.transactionHash) {
                  _context18.next = 34;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 34:
                if (result.blockNumber) {
                  _context18.next = 36;
                  break;
                }

                throw new ContractError(methodName, 302, result.transactionHash, "Transaction failed");

              case 36:
                return _context18.abrupt("return", result);

              case 37:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function consensusCloseChannelContractHandler(_x26) {
        return _ref32.apply(this, arguments);
      }

      return consensusCloseChannelContractHandler;
    }()

    /**
     * Calls joinChannel on the Channel Manager contract with the provided deposits. If no deposits are provided, joins with 0 deposits.
     *
     * The wallet must approve the transfer of the deposited tokens to the Channel Manager contract before calling this function.
     *
     * Calling this function will also serve you to serve as a "hub" in the contract.
     *
     * @example
     * // approve token transfers
     * const { channelId } = await connext.getChannelByPartyA("0x3ae...")
     * await connext.joinChannelContractHandler({ channelId })
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - the channelId of the channel you are joining
     * @param {Object} params.deposits - (optional) the deposits you are joining the channel with. Default value is 0.
     * @param {BN} params.deposits.weiDeposit - (optional) initial wei deposit into channel
     * @param {BN} params.deposits.tokenDeposit - (optional) initial token deposit into channel
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "joinChannelContractHandler",
    value: function () {
      var _ref34 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee19(_ref33) {
        var channelId = _ref33.channelId,
            _ref33$deposits = _ref33.deposits,
            deposits = _ref33$deposits === undefined ? null : _ref33$deposits,
            _ref33$sender = _ref33.sender,
            sender = _ref33$sender === undefined ? null : _ref33$sender;
        var methodName, isAddress, isHexStrict, isValidDepositObject, channel, result;
        return _regenerator2.default.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                methodName = "joinChannelContractHandler";
                isAddress = { presence: true, isAddress: true };
                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                if (deposit) {
                  Connext.validatorsResponseToError(validate.single(deposits, isValidDepositObject), methodName, "deposits");
                } else {
                  deposit = {
                    tokenDeposit: Web3.utils.toBN("0"),
                    weiDeposit: Web3.utils.toBN("0")
                  };
                }
                if (sender) {
                  Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                }
                _context19.next = 9;
                return this.getChannelById(channelId);

              case 9:
                channel = _context19.sent;

                if (channel) {
                  _context19.next = 12;
                  break;
                }

                throw new ChannelOpenError(methodName, "Channel is not openChanneled with hub");

              case 12:
                if (!(sender && sender.toLowerCase() === channel.partyA)) {
                  _context19.next = 14;
                  break;
                }

                throw new ChannelOpenError(methodName, "Cannot create channel with yourself");

              case 14:
                if (!(sender && sender !== channel.partyI)) {
                  _context19.next = 16;
                  break;
                }

                throw new ChannelOpenError(methodName, "Incorrect channel counterparty");

              case 16:
                if (!(CHANNEL_STATES[channel.status] !== CHANNEL_STATES.OPENED)) {
                  _context19.next = 18;
                  break;
                }

                throw new ChannelOpenError(methodName, "Channel is not in correct state");

              case 18:
                _context19.next = 20;
                return this.channelManagerInstance.methods.joinChannel(channelId, [deposit.weiDeposit ? deposit.weiDeposit : "0", deposit.tokenDeposit ? deposit.tokenDeposit : "0"]).send({
                  from: sender || this.hubAddress, // can also be accounts[0], easier for testing
                  value: deposit.weiDeposit ? deposit.weiDeposit : "0",
                  gas: 3000000 // FIX THIS, WHY HAPPEN, TRUFFLE CONFIG???
                });

              case 20:
                result = _context19.sent;

                if (result.transactionHash) {
                  _context19.next = 23;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 23:
                if (result.blockNumber) {
                  _context19.next = 25;
                  break;
                }

                throw new ContractError(methodName, 302, result.transactionHash, "Transaction failed");

              case 25:
                return _context19.abrupt("return", result);

              case 26:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function joinChannelContractHandler(_x27) {
        return _ref34.apply(this, arguments);
      }

      return joinChannelContractHandler;
    }()

    /**
     * Calls updateChannelState on the Channel Manager contract. Should be called if there is a dispute when fast closing a channel, or when you are beginning to dispute a thread.
     *
     * @example
     * // generate final state sigParams
     * const sig = await connext.createChannelStateUpdate(sigParams);
     * const { sigI } = await connext.fastCloseChannelHandler({
     *   sig,
     *   channelId: channel.channelId
     * });
     * if (!sigI) {
     *  const { channelId, nonce, numOpenThread, balanceA, balanceI, threadRootHash } = sigParams
     *  await connext.this.updateChannelStateContractHandler({ channelId, nonce, numOpenThread, balanceA, balanceI, threadRootHash })
     * }
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - ID of the channel you are disputing
     * @param {Number} params.nonce - the nonce of the state you are submitting to the contract
     * @param {Number} params.numOpenThread - the number of open threads in that channel state
     * @param {String} params.threadRootHash - root hash of the initial thread states for active threads in this channel
     * @param {Object} params.balanceA - partyA balance
     * @param {BN} params.balanceA.weiDeposit - (optional) wei balance of partyA in channel
     * @param {BN} params.balanceA.tokenDeposit - (optional) token balance of partyA in channel
     * @param {Object} params.balanceI - balance of hub in channel
     * @param {BN} params.balanceI.weiDeposit - (optional) wei balance of hub in channel
     * @param {BN} params.balanceI.tokenDeposit - (optional) token balance of hub in channel
     * @param {String} params.sigI - the hub signature on the state
     * @param {String} params.sigA - partyA's signature on the state
     * @param {String} params.sender - (optional) sender of the contract call. Defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "updateChannelStateContractHandler",
    value: function () {
      var _ref36 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee20(_ref35) {
        var channelId = _ref35.channelId,
            nonce = _ref35.nonce,
            numOpenThread = _ref35.numOpenThread,
            threadRootHash = _ref35.threadRootHash,
            balanceA = _ref35.balanceA,
            balanceI = _ref35.balanceI,
            sigA = _ref35.sigA,
            sigI = _ref35.sigI,
            _ref35$sender = _ref35.sender,
            sender = _ref35$sender === undefined ? null : _ref35$sender;
        var methodName, isHexStrict, isPositiveInt, isValidDepositObject, isHex, isAddress, accounts, weiBalanceA, weiBalanceI, tokenBalanceA, tokenBalanceI, result;
        return _regenerator2.default.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                methodName = "updateChannelStateContractHandler";
                // validate

                isHexStrict = { presence: true, isHexStrict: true };
                isPositiveInt = { presence: true, isPositiveInt: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isHex = { presence: true, isHex: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                Connext.validatorsResponseToError(validate.single(numOpenThread, isPositiveInt), methodName, "numOpenThread");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceI, isValidDepositObject), methodName, "balanceI");
                Connext.validatorsResponseToError(validate.single(threadRootHash, isHex), methodName, "threadRootHash");
                Connext.validatorsResponseToError(validate.single(sigA, isHex), methodName, "sigA");
                Connext.validatorsResponseToError(validate.single(sigI, isHex), methodName, "sigI");

                if (!sender) {
                  _context20.next = 18;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context20.next = 22;
                break;

              case 18:
                _context20.next = 20;
                return this.web3.eth.getAccounts();

              case 20:
                accounts = _context20.sent;

                sender = accounts[0].toLowerCase();

              case 22:
                weiBalanceA = balanceA.weiDeposit ? balanceA.weiDeposit : Web3.utils.toBN("0");
                weiBalanceI = balanceI.weiDeposit ? balanceI.weiDeposit : Web3.utils.toBN("0");
                tokenBalanceA = balanceA.tokenDeposit ? balanceA.tokenDeposit : Web3.utils.toBN("0");
                tokenBalanceI = balanceI.tokenDeposit ? balanceI.tokenDeposit : Web3.utils.toBN("0");
                _context20.next = 28;
                return this.channelManagerInstance.methods.updateChannelState(channelId, [nonce, numOpenThread, weiBalanceA, weiBalanceI, tokenBalanceA, tokenBalanceI], Web3.utils.padRight(threadRootHash, 64), sigA, sigI).send({
                  from: sender,
                  gas: "6721975"
                });

              case 28:
                result = _context20.sent;

                if (result.transactionHash) {
                  _context20.next = 31;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 31:
                if (result.blockNumber) {
                  _context20.next = 33;
                  break;
                }

                throw new ContractError(methodName, 302, result.transactionHash, "Transaction failed");

              case 33:
                return _context20.abrupt("return", result);

              case 34:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function updateChannelStateContractHandler(_x28) {
        return _ref36.apply(this, arguments);
      }

      return updateChannelStateContractHandler;
    }()

    /**
     * Calls initThreadState on the Channel Manager contract. Should be called if there is a dispute when closing a thread, after updateChannelState has timed out.
     *
     *
     * @param {Object} params - the method object
     * @param {String} params.subchanId - ID of the your subchannel in thread
     * @param {String} params.threadId - ID of the thread you are disputing
     * @param {String} params.proof - (optional) the proof the thread is in the on-chain root hash of the channel. If not provided, it is generated.
     * @param {String} params.partyA - partyA in thread (payor)
     * @param {String} params.partyB - partyB in thread (payee)
     * @param {Object} params.balanceA - partyA balance
     * @param {BN} params.balanceA.weiDeposit - (optional) wei balance of partyA in channel
     * @param {BN} params.balanceA.tokenDeposit - (optional) token balance of partyA in channel
     * @param {String} params.sigA - partyA's signature on the initial thread state
     * @param {String} params.sender - (optional) sender of the contract call. Defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "initThreadContractHandler",
    value: function () {
      var _ref38 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee21(_ref37) {
        var subchanId = _ref37.subchanId,
            threadId = _ref37.threadId,
            _ref37$proof = _ref37.proof,
            proof = _ref37$proof === undefined ? null : _ref37$proof,
            partyA = _ref37.partyA,
            partyB = _ref37.partyB,
            balanceA = _ref37.balanceA,
            sigA = _ref37.sigA,
            _ref37$sender = _ref37.sender,
            sender = _ref37$sender === undefined ? null : _ref37$sender;
        var methodName, isAddress, isHexStrict, isValidDepositObject, isHex, accounts, weiBalanceA, tokenBalanceA, merkle, stateHash, threadInitialStates, mproof, i, results;
        return _regenerator2.default.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                methodName = "initThreadContractHandler";
                // validate

                isAddress = { presence: true, isAddress: true };
                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isHex = { presence: true, isHex: true };

                Connext.validatorsResponseToError(validate.single(subchanId, isHexStrict), methodName, "subchanId");
                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
                Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(sigA, isHex), methodName, "sigA");

                if (!sender) {
                  _context21.next = 15;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context21.next = 19;
                break;

              case 15:
                _context21.next = 17;
                return this.web3.eth.getAccounts();

              case 17:
                accounts = _context21.sent;

                sender = accounts[0].toLowerCase();

              case 19:
                weiBalanceA = balanceA.weiDeposit ? balanceA.weiDeposit : Web3.utils.toBN("0");
                tokenBalanceA = balanceA.tokenDeposit ? balanceA.tokenDeposit : Web3.utils.toBN("0");
                merkle = void 0, stateHash = void 0;

                if (!(proof === null)) {
                  _context21.next = 33;
                  break;
                }

                // generate proof from channel
                stateHash = Connext.createThreadStateUpdateFingerprint({
                  channelId: threadId,
                  nonce: 0,
                  partyA: partyA,
                  partyB: partyB,
                  weiBalanceA: weiBalanceA,
                  weiBalanceB: Web3.utils.toBN("0"),
                  tokenBalanceA: tokenBalanceA,
                  tokenBalanceB: Web3.utils.toBN("0"),
                  weiBond: weiBalanceA,
                  tokenBond: tokenBalanceA
                });
                _context21.next = 26;
                return this.getThreadInitialStates(subchanId);

              case 26:
                threadInitialStates = _context21.sent;

                merkle = Connext.generateMerkleTree(threadInitialStates);
                mproof = merkle.proof(Utils.hexToBuffer(stateHash));


                proof = [];
                for (i = 0; i < mproof.length; i++) {
                  proof.push(Utils.bufferToHex(mproof[i]));
                }

                proof.unshift(stateHash);

                proof = Utils.marshallState(proof);

              case 33:
                _context21.next = 35;
                return this.channelManagerInstance.methods.initThreadState(subchanId, threadId, proof, partyA, partyB, [weiBalanceA, tokenBalanceA], [weiBalanceA, Web3.utils.toBN("0"), tokenBalanceA, Web3.utils.toBN("0")], sigA)
                // .estimateGas({
                //   from: sender,
                // })
                .send({
                  from: sender,
                  gas: 6721975
                });

              case 35:
                results = _context21.sent;

                if (results.transactionHash) {
                  _context21.next = 38;
                  break;
                }

                throw new Error("[" + methodName + "] initVCState transaction failed.");

              case 38:
                if (results.transactionHash) {
                  _context21.next = 40;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 40:
                if (results.blockNumber) {
                  _context21.next = 42;
                  break;
                }

                throw new ContractError(methodName, 302, results.transactionHash, "Transaction failed");

              case 42:
                return _context21.abrupt("return", results);

              case 43:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function initThreadContractHandler(_x29) {
        return _ref38.apply(this, arguments);
      }

      return initThreadContractHandler;
    }()

    /**
     * Calls settleThread on the Channel Manager contract. Should be called if there is a dispute when closing a thread, after initThread has timed out.
     *
     *
     * @param {Object} params - the method object
     * @param {String} params.subchanId - ID of the your subchannel in thread
     * @param {String} params.threadId - ID of the thread you are disputing
     * @param {Number} params.nonce - nonce of the state you are putting on-chain
     * @param {String} params.partyA - partyA in thread (payor)
     * @param {String} params.partyB - partyB in thread (payee)
     * @param {Object} params.balanceA - partyA balance
     * @param {BN} params.balanceA.weiDeposit - (optional) wei balance of partyA in channel
     * @param {BN} params.balanceA.tokenDeposit - (optional) token balance of partyA in channel
     * @param {Object} params.balanceB - partyB balance
     * @param {BN} params.balanceB.weiDeposit - (optional) wei balance of partyB in channel
     * @param {BN} params.balanceB.tokenDeposit - (optional) token balance of partyB in channel
     * @param {String} params.sigA - partyA's signature on the provided thread state
     * @param {String} params.sender - (optional) sender of the contract call. Defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "settleThreadContractHandler",
    value: function () {
      var _ref40 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee22(_ref39) {
        var subchanId = _ref39.subchanId,
            threadId = _ref39.threadId,
            nonce = _ref39.nonce,
            partyA = _ref39.partyA,
            partyB = _ref39.partyB,
            balanceA = _ref39.balanceA,
            balanceB = _ref39.balanceB,
            sigA = _ref39.sigA,
            _ref39$sender = _ref39.sender,
            sender = _ref39$sender === undefined ? null : _ref39$sender;
        var methodName, isAddress, isPositiveInt, isHexStrict, isValidDepositObject, isHex, accounts, weiBalanceA, weiBalanceB, tokenBalanceA, tokenBalanceB, results;
        return _regenerator2.default.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                methodName = "settleThreadContractHandler";
                // validate

                isAddress = { presence: true, isAddress: true };
                isPositiveInt = { presence: true, isPositiveInt: true };
                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };
                isHex = { presence: true, isHex: true };

                Connext.validatorsResponseToError(validate.single(subchanId, isHexStrict), methodName, "subchanId");
                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
                Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");
                Connext.validatorsResponseToError(validate.single(balanceA, isValidDepositObject), methodName, "balanceA");
                Connext.validatorsResponseToError(validate.single(balanceB, isValidDepositObject), methodName, "balanceB");
                Connext.validatorsResponseToError(validate.single(sigA, isHex), methodName, "sigA");

                if (!sender) {
                  _context22.next = 18;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context22.next = 22;
                break;

              case 18:
                _context22.next = 20;
                return this.web3.eth.getAccounts();

              case 20:
                accounts = _context22.sent;

                sender = accounts[0].toLowerCase();

              case 22:
                weiBalanceA = balanceA.weiDeposit ? balanceA.weiDeposit : Web3.utils.toBN("0");
                weiBalanceB = balanceB.weiDeposit ? balanceB.weiDeposit : Web3.utils.toBN("0");
                tokenBalanceA = balanceA.tokenDeposit ? balanceA.tokenDeposit : Web3.utils.toBN("0");
                tokenBalanceB = balanceB.tokenDeposit ? balanceB.tokenDeposit : Web3.utils.toBN("0");
                _context22.next = 28;
                return this.channelManagerInstance.methods.settleThread(subchanId, threadId, nonce, partyA, partyB, [weiBalanceA, weiBalanceB, tokenBalanceA, tokenBalanceB], sigA).send({
                  from: sender,
                  gas: 6721975
                });

              case 28:
                results = _context22.sent;

                if (results.transactionHash) {
                  _context22.next = 31;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 31:
                if (results.blockNumber) {
                  _context22.next = 33;
                  break;
                }

                throw new ContractError(methodName, 302, results.transactionHash, "Transaction failed");

              case 33:
                return _context22.abrupt("return", results);

              case 34:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function settleThreadContractHandler(_x30) {
        return _ref40.apply(this, arguments);
      }

      return settleThreadContractHandler;
    }()

    /**
     * Calls closeThread on the Channel Manager contract. Reintroduces the funds to their respective channels. Should be called after the settleThread dispute time has elapsed.
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - the ID of the disputer's channel
     * @param {String} params.threadId - the ID of the disputed thread
     * @param {String} params.sender - (optional) the sender of the contract call, defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "closeThreadContractHandler",
    value: function () {
      var _ref42 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee23(_ref41) {
        var channelId = _ref41.channelId,
            threadId = _ref41.threadId,
            _ref41$sender = _ref41.sender,
            sender = _ref41$sender === undefined ? null : _ref41$sender;
        var methodName, isHexStrict, isAddress, accounts, results;
        return _regenerator2.default.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                methodName = "closeThreadContractHandler";
                isHexStrict = { presence: true, isHexStrict: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");

                if (!sender) {
                  _context23.next = 9;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context23.next = 13;
                break;

              case 9:
                _context23.next = 11;
                return this.web3.eth.getAccounts();

              case 11:
                accounts = _context23.sent;

                sender = accounts[0].toLowerCase();

              case 13:
                _context23.next = 15;
                return this.channelManagerInstance.methods.closeThread(channelId, threadId).send({
                  from: sender
                });

              case 15:
                results = _context23.sent;

                if (results.transactionHash) {
                  _context23.next = 18;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 18:
                if (results.blockNumber) {
                  _context23.next = 20;
                  break;
                }

                throw new ContractError(methodName, 302, results.transactionHash, "Transaction failed");

              case 20:
                return _context23.abrupt("return", results);

              case 21:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function closeThreadContractHandler(_x31) {
        return _ref42.apply(this, arguments);
      }

      return closeThreadContractHandler;
    }()

    /**
     * Calls byzantineCloseChannel on the Channel Manager contract. Withdraws the funds from, and closes out, a disputed channel. Should be called after the updateChannelState dispute time has elapsed, and when there are no threads remaining open.
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - the ID of the disputer's channel
     * @param {String} params.threadId - the ID of the disputed thread
     * @param {String} params.sender - (optional) the sender of the contract call, defaults to accounts[0]
     *
     * @returns {Promise} resolves to the result of the contract call
     */

  }, {
    key: "byzantineCloseChannelContractHandler",
    value: function () {
      var _ref44 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee24(_ref43) {
        var channelId = _ref43.channelId,
            _ref43$sender = _ref43.sender,
            sender = _ref43$sender === undefined ? null : _ref43$sender;
        var methodName, isHexStrict, isAddress, accounts, results;
        return _regenerator2.default.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                methodName = "byzantineCloseChannelContractHandler";
                isHexStrict = { presence: true, isHexStrict: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");

                if (!sender) {
                  _context24.next = 8;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(sender, isAddress), methodName, "sender");
                _context24.next = 12;
                break;

              case 8:
                _context24.next = 10;
                return this.web3.eth.getAccounts();

              case 10:
                accounts = _context24.sent;

                sender = accounts[0].toLowerCase();

              case 12:
                _context24.next = 14;
                return this.channelManagerInstance.methods.byzantineCloseChannel(channelId).send({
                  from: sender,
                  gas: "470000"
                });

              case 14:
                results = _context24.sent;

                if (results.transactionHash) {
                  _context24.next = 17;
                  break;
                }

                throw new ContractError(methodName, 301, "Transaction failed to broadcast");

              case 17:
                if (results.blockNumber) {
                  _context24.next = 19;
                  break;
                }

                throw new ContractError(methodName, 302, results.transactionHash, "Transaction failed");

              case 19:
                return _context24.abrupt("return", results);

              case 20:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function byzantineCloseChannelContractHandler(_x32) {
        return _ref44.apply(this, arguments);
      }

      return byzantineCloseChannelContractHandler;
    }()

    // ***************************************
    // ********** ERROR HELPERS **************
    // ***************************************

  }, {
    key: "getUnjoinedThreads",


    // ***************************************
    // *********** INGRID GETTERS ************
    // ***************************************

    /**
     * Requests the unjoined threads that have been initiated. All threads are unidirectional, and only the reciever of payments may have unjoined threads.
     *
     * In reality, partyB does not have to explicitly join threads as they are unidirectional, so all threads may be unjoined.
     *
     * @param {String} partyB - (optional) ETH address of party who has yet to join threads.
     *
     * @returns {Promise} resolves to an array of unjoined virtual channel objects
     */
    value: function () {
      var _ref45 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee25() {
        var partyB = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var methodName, isAddress, accounts, response;
        return _regenerator2.default.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                methodName = "getUnjoinedThreads";
                isAddress = { presence: true, isAddress: true };

                if (!partyB) {
                  _context25.next = 6;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");
                _context25.next = 10;
                break;

              case 6:
                _context25.next = 8;
                return this.web3.eth.getAccounts();

              case 8:
                accounts = _context25.sent;

                partyB = accounts[0].toLowerCase();

              case 10:
                _context25.next = 12;
                return this.networking.get("thread/address/" + partyB.toLowerCase() + "/opening");

              case 12:
                response = _context25.sent;
                return _context25.abrupt("return", response.data);

              case 14:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function getUnjoinedThreads() {
        return _ref45.apply(this, arguments);
      }

      return getUnjoinedThreads;
    }()

    /**
     * Returns all open channels with the hub.
     */

  }, {
    key: "getAllChannels",
    value: function () {
      var _ref46 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee26() {
        var response;
        return _regenerator2.default.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return this.networking.get("channel/");

              case 2:
                response = _context26.sent;
                return _context26.abrupt("return", response.data);

              case 4:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function getAllChannels() {
        return _ref46.apply(this, arguments);
      }

      return getAllChannels;
    }()

    /**
     * Returns the thread state at a given nonce.
     *
     * @param {Object} params - the method object
     * @param {String} params.threadId - the ID of the thread
     * @param {Number} params.nonce - the desired state's nonce
     *
     * @returns {Promise} resolves to the thread state at the given nonce
     */

  }, {
    key: "getThreadStateByNonce",
    value: function () {
      var _ref48 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee27(_ref47) {
        var threadId = _ref47.threadId,
            nonce = _ref47.nonce;
        var methodName, isHexStrict, isPositiveInt, response;
        return _regenerator2.default.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                methodName = "getThreadStateByNonce";
                isHexStrict = { presence: true, isHexStrict: true };
                isPositiveInt = { presence: true, isPositiveInt: true };

                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                _context27.next = 7;
                return this.networking.get("thread/" + threadId + "/update/" + nonce);

              case 7:
                response = _context27.sent;
                return _context27.abrupt("return", response.data);

              case 9:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function getThreadStateByNonce(_x34) {
        return _ref48.apply(this, arguments);
      }

      return getThreadStateByNonce;
    }()

    /**
     * Returns the channel state at a given nonce.
     *
     * @param {Object} params - the method object
     * @param {String} params.channel - the ID of the channel
     * @param {Number} params.nonce - the desired state's nonce
     *
     * @returns {Promise} resolves to the channel state at the given nonce
     */

  }, {
    key: "getChannelStateByNonce",
    value: function () {
      var _ref50 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee28(_ref49) {
        var channelId = _ref49.channelId,
            nonce = _ref49.nonce;
        var methodName, isHexStrict, isPositiveInt, response;
        return _regenerator2.default.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                methodName = "getChannelStateByNonce";
                isHexStrict = { presence: true, isHexStrict: true };
                isPositiveInt = { presence: true, isPositiveInt: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
                _context28.next = 7;
                return this.networking.get("channel/" + channelId + "/update/" + nonce);

              case 7:
                response = _context28.sent;
                return _context28.abrupt("return", response.data);

              case 9:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function getChannelStateByNonce(_x35) {
        return _ref50.apply(this, arguments);
      }

      return getChannelStateByNonce;
    }()

    /**
     * Returns the latest channel state.
     *
     * @param {String} channelId - the ID of the thread
     *
     * @returns {Promise} resolves to the latest channel state
     */

  }, {
    key: "getLatestChannelState",
    value: function () {
      var _ref51 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee29(channelId) {
        var methodName, isHexStrict, response;
        return _regenerator2.default.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                // lcState == latest ingrid signed state
                methodName = "getLatestChannelState";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");

                _context29.next = 5;
                return this.networking.get("channel/" + channelId + "/update/latest");

              case 5:
                response = _context29.sent;
                return _context29.abrupt("return", response.data);

              case 7:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this);
      }));

      function getLatestChannelState(_x36) {
        return _ref51.apply(this, arguments);
      }

      return getLatestChannelState;
    }()

    /**
     * Returns an array of the threads associated with the given channel.
     *
     * @param {String} channelId - ID of the ledger channel
     * @returns {Promise} resolves to an array of thread objects
     */

  }, {
    key: "getThreadsByChannelId",
    value: function () {
      var _ref52 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee30(channelId) {
        var methodName, isHexStrict, response;
        return _regenerator2.default.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                methodName = "getThreadsByChannelId";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");

                _context30.next = 5;
                return this.networking.get("channel/" + channelId + "/threads");

              case 5:
                response = _context30.sent;
                return _context30.abrupt("return", response.data);

              case 7:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));

      function getThreadsByChannelId(_x37) {
        return _ref52.apply(this, arguments);
      }

      return getThreadsByChannelId;
    }()

    /**
     * Returns the thread.
     *
     * @param {String} threadId - the ID of the thread
     * @returns {Promise} resolves to the thread object
     */

  }, {
    key: "getThreadById",
    value: function () {
      var _ref53 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee31(threadId) {
        var methodName, isHexStrict, response;
        return _regenerator2.default.wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                methodName = "getThreadById";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                _context31.prev = 3;
                _context31.next = 6;
                return this.networking.get("thread/" + threadId);

              case 6:
                response = _context31.sent;
                return _context31.abrupt("return", response.data);

              case 10:
                _context31.prev = 10;
                _context31.t0 = _context31["catch"](3);

                if (!(_context31.t0.status === 404)) {
                  _context31.next = 16;
                  break;
                }

                return _context31.abrupt("return", null);

              case 16:
                throw _context31.t0;

              case 17:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31, this, [[3, 10]]);
      }));

      function getThreadById(_x38) {
        return _ref53.apply(this, arguments);
      }

      return getThreadById;
    }()

    /**
     * Returns the threads between the two parties. If there are no threads, returns null.
     *
     * @param {Object} params - the method object
     * @param {String} params.partyA - ETH address of partyA in virtual channel
     * @param {String} params.partyB - ETH address of partyB in virtual channel
     * @returns {Promise} resolves to the thread
     */

  }, {
    key: "getThreadByParties",
    value: function () {
      var _ref55 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee32(_ref54) {
        var partyA = _ref54.partyA,
            partyB = _ref54.partyB,
            _ref54$status = _ref54.status,
            status = _ref54$status === undefined ? null : _ref54$status;
        var methodName, isAddress, response, threads;
        return _regenerator2.default.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                methodName = "getThreadByParties";
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
                Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");
                if (!status) {
                  status = THREAD_STATES.OPENED;
                }
                response = void 0;
                _context32.prev = 6;
                _context32.next = 9;
                return this.networking.get("thread/a/" + partyA.toLowerCase() + "/b/" + partyB.toLowerCase());

              case 9:
                response = _context32.sent;
                _context32.next = 19;
                break;

              case 12:
                _context32.prev = 12;
                _context32.t0 = _context32["catch"](6);

                if (!(_context32.t0.status === 404)) {
                  _context32.next = 18;
                  break;
                }

                return _context32.abrupt("return", null);

              case 18:
                throw _context32.t0;

              case 19:
                threads = response.data.filter(function (val) {
                  return val.status === status;
                });

                if (!(status === THREAD_STATES.OPENED)) {
                  _context32.next = 24;
                  break;
                }

                return _context32.abrupt("return", threads[0]);

              case 24:
                return _context32.abrupt("return", threads);

              case 25:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this, [[6, 12]]);
      }));

      function getThreadByParties(_x39) {
        return _ref55.apply(this, arguments);
      }

      return getThreadByParties;
    }()

    /**
     * Returns an object representing a channel.
     *
     * @param {String} channelId - the ledger channel id
     * @returns {Promise} resolves to the ledger channel object
     */

  }, {
    key: "getChannelById",
    value: function () {
      var _ref56 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee33(channelId) {
        var methodName, isHexStrict, res;
        return _regenerator2.default.wrap(function _callee33$(_context33) {
          while (1) {
            switch (_context33.prev = _context33.next) {
              case 0:
                methodName = "getChannelById";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                _context33.prev = 3;
                _context33.next = 6;
                return this.networking.get("channel/" + channelId);

              case 6:
                res = _context33.sent;
                return _context33.abrupt("return", res.data);

              case 10:
                _context33.prev = 10;
                _context33.t0 = _context33["catch"](3);

                if (!(_context33.t0.status === 404)) {
                  _context33.next = 14;
                  break;
                }

                return _context33.abrupt("return", null);

              case 14:
                throw _context33.t0;

              case 15:
              case "end":
                return _context33.stop();
            }
          }
        }, _callee33, this, [[3, 10]]);
      }));

      function getChannelById(_x40) {
        return _ref56.apply(this, arguments);
      }

      return getChannelById;
    }()

    /**
     * Returns the channel between partyA and the hub.
     *
     * @param {String} partyA - (optional) partyA in ledger channel. Default is accounts[0]
     * @returns {Promise} resolves to channel object
     */

  }, {
    key: "getChannelByPartyA",
    value: function () {
      var _ref57 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee34() {
        var partyA = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var methodName, isAddress, accounts, response;
        return _regenerator2.default.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                methodName = "getChannelByPartyA";
                isAddress = { presence: true, isAddress: true };

                if (!(partyA !== null)) {
                  _context34.next = 6;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
                _context34.next = 10;
                break;

              case 6:
                _context34.next = 8;
                return this.web3.eth.getAccounts();

              case 8:
                accounts = _context34.sent;

                partyA = accounts[0];

              case 10:
                _context34.prev = 10;
                _context34.next = 13;
                return this.networking.get("channel/a/" + partyA.toLowerCase());

              case 13:
                response = _context34.sent;

                if (!(response.data && response.data.length === 0)) {
                  _context34.next = 18;
                  break;
                }

                return _context34.abrupt("return", null);

              case 18:
                if (!(response.data.length === 1)) {
                  _context34.next = 22;
                  break;
                }

                return _context34.abrupt("return", response.data[0]);

              case 22:
                return _context34.abrupt("return", response.data);

              case 23:
                _context34.next = 32;
                break;

              case 25:
                _context34.prev = 25;
                _context34.t0 = _context34["catch"](10);

                if (!(_context34.t0.status === 404)) {
                  _context34.next = 31;
                  break;
                }

                return _context34.abrupt("return", null);

              case 31:
                throw _context34.t0;

              case 32:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this, [[10, 25]]);
      }));

      function getChannelByPartyA() {
        return _ref57.apply(this, arguments);
      }

      return getChannelByPartyA;
    }()

    /**
     * Returns the latest thread state of the given threadId.
     *
     * @param {String} threadId - ID of thread
     * @returns {Promise} resolves to thread state
     */

  }, {
    key: "getLatestThreadState",
    value: function () {
      var _ref58 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee35(threadId) {
        var methodName, isHexStrict, response;
        return _regenerator2.default.wrap(function _callee35$(_context35) {
          while (1) {
            switch (_context35.prev = _context35.next) {
              case 0:
                // validate params
                methodName = "getLatestThreadState";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                _context35.next = 5;
                return this.networking.get("thread/" + threadId + "/update/latest");

              case 5:
                response = _context35.sent;
                return _context35.abrupt("return", response.data);

              case 7:
              case "end":
                return _context35.stop();
            }
          }
        }, _callee35, this);
      }));

      function getLatestThreadState(_x42) {
        return _ref58.apply(this, arguments);
      }

      return getLatestThreadState;
    }()

    /**
     * Returns the initial thread states for all open threads associated with the channelId.
     *
     * @param {String} channelId - ID of channel
     * @returns {Promise} resolves to an array of initial thread states
     */

  }, {
    key: "getThreadInitialStates",
    value: function () {
      var _ref59 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee36(channelId) {
        var methodName, isHexStrict, response;
        return _regenerator2.default.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                // validate params
                methodName = "getThreadInitialStates";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                _context36.next = 5;
                return this.networking.get("channel/" + channelId + "/threadInitialStates");

              case 5:
                response = _context36.sent;
                return _context36.abrupt("return", response.data);

              case 7:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));

      function getThreadInitialStates(_x43) {
        return _ref59.apply(this, arguments);
      }

      return getThreadInitialStates;
    }()

    /**
     * Returns the initial state of the thread
     *
     * @param {String} threadId - ID of thread
     * @returns {Promise} resolves to a thread state object
     */

  }, {
    key: "getThreadInitialState",
    value: function () {
      var _ref60 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee37(threadId) {
        var methodName, isHexStrict, response;
        return _regenerator2.default.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                // validate params
                methodName = "getThreadInitialState";
                isHexStrict = { presence: true, isHexStrict: true };

                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");
                _context37.next = 5;
                return this.networking.get("thread/" + threadId + "/update/0");

              case 5:
                response = _context37.sent;
                return _context37.abrupt("return", response.data);

              case 7:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));

      function getThreadInitialState(_x44) {
        return _ref60.apply(this, arguments);
      }

      return getThreadInitialState;
    }()

    // ***************************************
    // *********** INGRID HELPERS ************
    // ***************************************

    /**
     * Requests hub deposits into a given channel. Hub must have sufficient balance in the "B" subchannel to cover the thread balance of "A".
     *
     * This function is to be used if the hub has insufficient balance in the channel to create proposed threads.
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - id of the ledger channel
     * @param {Object} params.deposit - the requested hub deposit
     * @param {Object} params.deposit.weiDeposit - (optional) the requested hub wei deposit
     * @param {Object} params.deposit.tokenDeposit - (optional) the requested hub token deposit
     * @returns {Promise} resolves to the transaction hash of Ingrid calling the deposit function
     */

  }, {
    key: "requestHubDeposit",
    value: function () {
      var _ref62 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee38(_ref61) {
        var channelId = _ref61.channelId,
            deposit = _ref61.deposit;
        var methodName, isHexStrict, isValidDepositObject, accountBalance, response;
        return _regenerator2.default.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                methodName = "requestHubDeposit";
                isHexStrict = { presence: true, isHexStrict: true };
                isValidDepositObject = { presence: true, isValidDepositObject: true };

                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                Connext.validatorsResponseToError(validate.single(deposit, isValidDepositObject), methodName, "deposit");
                _context38.next = 7;
                return this.web3.eth.getBalance(this.hubAddress);

              case 7:
                accountBalance = _context38.sent;

                if (!(deposit.weiDeposit && deposit.weiDeposit.gt(Web3.utils.toBN(accountBalance)))) {
                  _context38.next = 10;
                  break;
                }

                throw new ChannelUpdateError(methodName, "Hub does not have sufficient ETH balance for requested deposit");

              case 10:
                _context38.next = 12;
                return this.networking.post("channel/" + channelId + "/requestdeposit", {
                  weiDeposit: deposit.weiDeposit ? deposit.weiDeposit.toString() : "0",
                  tokenDeposit: deposit.tokenDeposit ? deposit.tokenDeposit.toString() : "0"
                });

              case 12:
                response = _context38.sent;
                return _context38.abrupt("return", response.data.txHash);

              case 14:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));

      function requestHubDeposit(_x45) {
        return _ref62.apply(this, arguments);
      }

      return requestHubDeposit;
    }()

    /**
     * Posts a request to the hub to close a thread.
     *
     * @param {Object} params
     * @param {String} params.sig - the sig on the proposed subchannel update
     * @param {String} params.threadId - ID of the thread you are closing
     * @param {String} params.signer - (optional) signer of the update (should be partyA in thread)
     *
     * @returns {Promise} resolves to true if the thread was closed, false if it was not
     */

  }, {
    key: "fastCloseThreadHandler",
    value: function () {
      var _ref64 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee39(_ref63) {
        var sig = _ref63.sig,
            threadId = _ref63.threadId,
            _ref63$signer = _ref63.signer,
            signer = _ref63$signer === undefined ? null : _ref63$signer;
        var methodName, isHex, isHexStrict, isAddress, accounts, response;
        return _regenerator2.default.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                // validate params
                methodName = "fastCloseThreadHandler";
                isHex = { presence: true, isHex: true };
                isHexStrict = { presence: true, isHexStrict: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(sig, isHex), methodName, "sig");

                if (!signer) {
                  _context39.next = 9;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(signer, isAddress), methodName, "signer");
                _context39.next = 13;
                break;

              case 9:
                _context39.next = 11;
                return this.web3.eth.getAccounts();

              case 11:
                accounts = _context39.sent;

                signer = accounts[0].toLowerCase();

              case 13:
                Connext.validatorsResponseToError(validate.single(threadId, isHexStrict), methodName, "threadId");

                _context39.next = 16;
                return this.networking.post("thread/" + threadId + "/close", {
                  sig: sig,
                  signer: signer
                });

              case 16:
                response = _context39.sent;
                return _context39.abrupt("return", THREAD_STATES[response.data.status] !== Object.keys(THREAD_STATES)[THREAD_STATES.SETTLED]);

              case 18:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));

      function fastCloseThreadHandler(_x46) {
        return _ref64.apply(this, arguments);
      }

      return fastCloseThreadHandler;
    }()

    /**
     * Posts a request to the hub to cosign a final channel update with the fast close flag. Hub will only cosign if there are no threads open, and all updates are in sync.
     *
     * @param {Object} params
     * @param {String} params.sig - the sig on the proposed subchannel update
     * @param {String} params.channelId - ID of the channel you are closing
     *
     * @returns {Promise} resolves to the final cosigned state
     */

  }, {
    key: "fastCloseChannelHandler",
    value: function () {
      var _ref66 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee40(_ref65) {
        var sig = _ref65.sig,
            channelId = _ref65.channelId;
        var methodName, isHexStrict, isHex, response;
        return _regenerator2.default.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                // validate params
                methodName = "fastCloseChannelHandler";
                isHexStrict = { presence: true, isHexStrict: true };
                isHex = { presence: true, isHex: true };

                Connext.validatorsResponseToError(validate.single(sig, isHex), methodName, "sig");
                Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
                _context40.next = 7;
                return this.networking.post("channel/" + channelId + "/close", {
                  sig: sig
                });

              case 7:
                response = _context40.sent;
                return _context40.abrupt("return", response.data);

              case 9:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));

      function fastCloseChannelHandler(_x47) {
        return _ref66.apply(this, arguments);
      }

      return fastCloseChannelHandler;
    }()

    /**
     * Creates a signed channel update when a thread is opened.
     *
     * @param {Object} params - the method object
     * @param {Object} params.threadInitialState - the initial state of the proposed thread
     * @param {Object} params.channel - the signer's subchannel of the proposed thread
     * @param {String} params.signer - (optional) signer of update. Defaults to accounts[0]
     *
     * @returns {Promise} resolves to the signature of the signer on the channel update
     */

  }, {
    key: "createChannelUpdateOnThreadOpen",
    value: function () {
      var _ref68 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee41(_ref67) {
        var threadInitialState = _ref67.threadInitialState,
            subchan = _ref67.subchan,
            _ref67$signer = _ref67.signer,
            signer = _ref67$signer === undefined ? null : _ref67$signer;
        var methodName, isThreadState, isChannelObj, isAddress, accounts, threadInitialStates, newRootHash, channelweiBalanceA, channelTokenBalanceA, channelTokenBalanceI, channelweiBalanceI, updateAtoI, sigAtoI;
        return _regenerator2.default.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                methodName = "createChannelUpdateOnThreadOpen";
                isThreadState = { presence: true, isThreadState: true };
                isChannelObj = { presence: true, isChannelObj: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(threadInitialState, isThreadState), methodName, "threadInitialState");
                Connext.validatorsResponseToError(validate.single(subchan, isChannelObj), methodName, "subchan");

                if (!signer) {
                  _context41.next = 10;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(signer, isAddress), methodName, "signer");
                _context41.next = 14;
                break;

              case 10:
                _context41.next = 12;
                return this.web3.eth.getAccounts();

              case 12:
                accounts = _context41.sent;

                signer = accounts[0].toLowerCase();

              case 14:
                if (!(signer.toLowerCase() !== subchan.partyA)) {
                  _context41.next = 16;
                  break;
                }

                throw new ThreadOpenError(methodName, "Invalid signer detected");

              case 16:
                if (!(signer.toLowerCase() !== threadInitialState.partyA.toLowerCase() && signer.toLowerCase() !== threadInitialState.partyB.toLowerCase())) {
                  _context41.next = 18;
                  break;
                }

                throw new ThreadOpenError(methodName, "Invalid signer detected");

              case 18:
                if (!(CHANNEL_STATES[subchan.status] !== CHANNEL_STATES.JOINED)) {
                  _context41.next = 20;
                  break;
                }

                throw new ThreadOpenError(methodName, "Invalid subchannel state");

              case 20:
                if (!(threadInitialState.nonce !== 0)) {
                  _context41.next = 22;
                  break;
                }

                throw new ThreadOpenError(methodName, "Thread nonce is nonzero");

              case 22:
                if (!(threadInitialState.balanceA.weiDeposit && Web3.utils.toBN(subchan.weiBalanceA).lt(threadInitialState.balanceA.weiDeposit))) {
                  _context41.next = 24;
                  break;
                }

                throw new ThreadOpenError(methodName, "Insufficient ETH deposit detected for balanceA");

              case 24:
                if (!(threadInitialState.balanceA.tokenDeposit && Web3.utils.toBN(subchan.tokenBalanceA).lt(threadInitialState.balanceA.tokenDeposit))) {
                  _context41.next = 26;
                  break;
                }

                throw new ThreadOpenError(methodName, "Insufficient token deposit detected for balanceA");

              case 26:
                if (!(threadInitialState.balanceB.weiDeposit && !threadInitialState.balanceB.weiDeposit.isZero())) {
                  _context41.next = 28;
                  break;
                }

                throw new ThreadOpenError(methodName, "The ETH balanceB must be 0 when creating thread.");

              case 28:
                if (!(threadInitialState.balanceB.tokenDeposit && !threadInitialState.balanceB.tokenDeposit.isZero())) {
                  _context41.next = 30;
                  break;
                }

                throw new ThreadOpenError(methodName, "The token balanceB must be 0 when creating thread.");

              case 30:
                // manipulate threadInitialState to have the right data structure
                threadInitialState.weiBalanceA = threadInitialState.balanceA.weiDeposit ? threadInitialState.balanceA.weiDeposit : Web3.utils.toBN("0");
                threadInitialState.weiBalanceB = Web3.utils.toBN("0");
                threadInitialState.tokenBalanceA = threadInitialState.balanceA.tokenDeposit ? threadInitialState.balanceA.tokenDeposit : Web3.utils.toBN("0");
                threadInitialState.tokenBalanceB = Web3.utils.toBN("0");

                threadInitialState.weiBond = threadInitialState.weiBalanceA.add(threadInitialState.weiBalanceB);
                threadInitialState.tokenBond = threadInitialState.tokenBalanceA.add(threadInitialState.tokenBalanceB);

                _context41.next = 38;
                return this.getThreadInitialStates(subchan.channelId);

              case 38:
                threadInitialStates = _context41.sent;

                threadInitialStates.push(threadInitialState); // add new vc state to hash
                newRootHash = Connext.generateThreadRootHash({
                  threadInitialStates: threadInitialStates
                });

                // new LC balances should reflect the VC deposits
                // new balanceA = balanceA - (their VC balance)

                channelweiBalanceA = signer.toLowerCase() === threadInitialState.partyA.toLowerCase() ? Web3.utils.toBN(subchan.weiBalanceA).sub(threadInitialState.weiBalanceA) // viewer is signing LC update
                : Web3.utils.toBN(subchan.weiBalanceA).sub(threadInitialState.weiBalanceB); // performer is signing LC update

                channelTokenBalanceA = signer.toLowerCase() === threadInitialState.partyA.toLowerCase() ? Web3.utils.toBN(subchan.tokenBalanceA).sub(threadInitialState.tokenBalanceA) : Web3.utils.toBN(subchan.tokenBalanceA).sub(threadInitialState.tokenBalanceB);

                // new balanceI = balanceI - (counterparty VC balance)

                channelTokenBalanceI = signer.toLowerCase() === threadInitialState.partyA.toLowerCase() ? Web3.utils.toBN(subchan.tokenBalanceI).sub(threadInitialState.tokenBalanceB) : Web3.utils.toBN(subchan.tokenBalanceI).sub(threadInitialState.tokenBalanceA);
                channelweiBalanceI = signer.toLowerCase() === threadInitialState.partyA.toLowerCase() ? Web3.utils.toBN(subchan.weiBalanceI).sub(threadInitialState.weiBalanceB) : Web3.utils.toBN(subchan.weiBalanceI).sub(threadInitialState.weiBalanceA); //

                updateAtoI = {
                  channelId: subchan.channelId,
                  nonce: subchan.nonce + 1,
                  numOpenThread: threadInitialStates.length,
                  threadRootHash: newRootHash,
                  partyA: subchan.partyA,
                  partyI: this.hubAddress,
                  balanceA: {
                    weiDeposit: channelweiBalanceA,
                    tokenDeposit: channelTokenBalanceA
                  },
                  balanceI: {
                    weiDeposit: channelweiBalanceI,
                    tokenDeposit: channelTokenBalanceI
                  },
                  signer: signer,
                  hubBond: {
                    weiDeposit: threadInitialState.weiBalanceA.add(threadInitialState.weiBalanceB),
                    tokenDeposit: threadInitialState.tokenBalanceA.add(threadInitialState.tokenBalanceB)
                  }
                };
                _context41.next = 48;
                return this.createChannelStateUpdate(updateAtoI);

              case 48:
                sigAtoI = _context41.sent;
                return _context41.abrupt("return", sigAtoI);

              case 50:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this);
      }));

      function createChannelUpdateOnThreadOpen(_x48) {
        return _ref68.apply(this, arguments);
      }

      return createChannelUpdateOnThreadOpen;
    }()

    /**
     * Creates a signed channel update when a thread is closed.
     *
     * @param {Object} params - the method object
     * @param {Object} params.latestThreadState - the closing state of the proposed thread
     * @param {Object} params.subchan - the signer's subchannel of the thread
     * @param {String} params.signer - (optional) signer of update. Defaults to accounts[0]
     *
     * @returns {Promise} resolves to the signature of the signer on the channel update
     */

  }, {
    key: "createChannelUpdateOnThreadClose",
    value: function () {
      var _ref70 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee42(_ref69) {
        var latestThreadState = _ref69.latestThreadState,
            subchan = _ref69.subchan,
            _ref69$signer = _ref69.signer,
            signer = _ref69$signer === undefined ? null : _ref69$signer;
        var methodName, isThreadState, isChannelObj, isAddress, accounts, threadInitialStates, newRootHash, subchanweiBalanceA, subchanweiBalanceI, subchanTokenBalanceA, subchanTokenBalanceI, updateAtoI, sigAtoI;
        return _regenerator2.default.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                methodName = "createChannelUpdateOnThreadClose";
                isThreadState = { presence: true, isThreadState: true };
                isChannelObj = { presence: true, isChannelObj: true };
                isAddress = { presence: true, isAddress: true };

                Connext.validatorsResponseToError(validate.single(latestThreadState, isThreadState), methodName, "latestThreadState");
                Connext.validatorsResponseToError(validate.single(subchan, isChannelObj), methodName, "subchan");

                if (!signer) {
                  _context42.next = 10;
                  break;
                }

                Connext.validatorsResponseToError(validate.single(signer, isAddress), methodName, "signer");
                _context42.next = 14;
                break;

              case 10:
                _context42.next = 12;
                return this.web3.eth.getAccounts();

              case 12:
                accounts = _context42.sent;

                signer = accounts[0].toLowerCase();

              case 14:
                if (!(signer.toLowerCase() !== subchan.partyA)) {
                  _context42.next = 16;
                  break;
                }

                throw new ThreadCloseError(methodName, "Incorrect signer detected");

              case 16:
                if (!(signer.toLowerCase() !== latestThreadState.partyA.toLowerCase() && signer.toLowerCase() !== latestThreadState.partyB.toLowerCase())) {
                  _context42.next = 18;
                  break;
                }

                throw new ThreadCloseError(methodName, "Not your channel");

              case 18:
                if (!(CHANNEL_STATES[subchan.status] !== CHANNEL_STATES.JOINED && CHANNEL_STATES[subchan.status] !== CHANNEL_STATES.SETTLING)) {
                  _context42.next = 20;
                  break;
                }

                throw new ThreadCloseError(methodName, "Channel is in invalid state");

              case 20:
                _context42.next = 22;
                return this.getThreadInitialStates(subchan.channelId);

              case 22:
                threadInitialStates = _context42.sent;

                // array of state objects, which include the channel id and nonce
                // remove initial state of vcN
                threadInitialStates = threadInitialStates.filter(function (threadState) {
                  return threadState.threadId !== latestThreadState.threadId;
                });

                newRootHash = Connext.generateThreadRootHash({
                  threadInitialStates: threadInitialStates
                });

                // add balance from thread to channel balance

                subchanweiBalanceA = signer.toLowerCase() === latestThreadState.partyA ? Web3.utils.toBN(subchan.weiBalanceA).add(Web3.utils.toBN(latestThreadState.weiBalanceA)) : Web3.utils.toBN(subchan.weiBalanceA).add(Web3.utils.toBN(latestThreadState.weiBalanceB));
                // add counterparty balance from thread to channel balance

                subchanweiBalanceI = signer.toLowerCase() === latestThreadState.partyA ? Web3.utils.toBN(subchan.weiBalanceI).add(Web3.utils.toBN(latestThreadState.weiBalanceB)) : Web3.utils.toBN(subchan.weiBalanceI).add(Web3.utils.toBN(latestThreadState.weiBalanceA));
                subchanTokenBalanceA = signer.toLowerCase() === latestThreadState.partyA ? Web3.utils.toBN(subchan.tokenBalanceA).add(Web3.utils.toBN(latestThreadState.tokenBalanceA)) : Web3.utils.toBN(subchan.tokenBalanceA).add(Web3.utils.toBN(latestThreadState.tokenBalanceB));
                subchanTokenBalanceI = signer.toLowerCase() === latestThreadState.partyA ? Web3.utils.toBN(subchan.tokenBalanceI).add(Web3.utils.toBN(latestThreadState.tokenBalanceB)) : Web3.utils.toBN(subchan.tokenBalanceI).add(Web3.utils.toBN(latestThreadState.tokenBalanceA));
                updateAtoI = {
                  channelId: subchan.channelId,
                  nonce: subchan.nonce + 1,
                  numOpenThread: threadInitialStates.length,
                  threadRootHash: newRootHash,
                  partyA: signer,
                  partyI: this.hubAddress,
                  balanceA: {
                    weiDeposit: subchanweiBalanceA,
                    tokenDeposit: subchanTokenBalanceA
                  },
                  balanceI: {
                    weiDeposit: subchanweiBalanceI,
                    tokenDeposit: subchanTokenBalanceI
                  },
                  hubBond: {
                    weiDeposit: Web3.utils.toBN(latestThreadState.weiBalanceA).add(Web3.utils.toBN(latestThreadState.weiBalanceB)),
                    tokenDeposit: Web3.utils.toBN(latestThreadState.tokenBalanceA).add(Web3.utils.toBN(latestThreadState.tokenBalanceB))
                  },
                  signer: signer
                };
                _context42.next = 32;
                return this.createChannelStateUpdate(updateAtoI);

              case 32:
                sigAtoI = _context42.sent;
                return _context42.abrupt("return", sigAtoI);

              case 34:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this);
      }));

      function createChannelUpdateOnThreadClose(_x49) {
        return _ref70.apply(this, arguments);
      }

      return createChannelUpdateOnThreadClose;
    }()
  }], [{
    key: "getNewChannelId",
    value: function getNewChannelId() {
      var buf = crypto.randomBytes(32);
      var channelId = Web3.utils.bytesToHex(buf);
      return channelId;
    }

    /**
     * Hashes the channel state using web3's soliditySha3.
     *
     * @param {Object} params - the method object (representing channel state)
     * @param {String} params.channelId - channelId
     * @param {Boolean} params.isClose - flag indicating whether or not this is closing state
     * @param {Number} params.nonce - the sequence of the channel update
     * @param {Number} params.numOpenThread - the number of open threads  associated with this channel
     * @param {String} params.threadRootHash - the root hash of the Merkle tree containing all initial states of the open threads
     * @param {String} params.partyA - ETH address of partyA in the channel
     * @param {String} params.partyI - ETH address of the hub
     * @param {BN} params.weiBalanceA - wei balance of partyA
     * @param {BN} params.weiBalanceI - wei balance of hub
     * @param {BN} params.tokenBalanceA - wei balance of partyA
     * @param {BN} params.tokenBalanceI - wei balance of hub
     *
     * @returns {String} the hash of the state data
     */

  }, {
    key: "createChannelStateUpdateFingerprint",
    value: function createChannelStateUpdateFingerprint(_ref71) {
      var channelId = _ref71.channelId,
          isClose = _ref71.isClose,
          nonce = _ref71.nonce,
          numOpenThread = _ref71.numOpenThread,
          threadRootHash = _ref71.threadRootHash,
          partyA = _ref71.partyA,
          partyI = _ref71.partyI,
          weiBalanceA = _ref71.weiBalanceA,
          weiBalanceI = _ref71.weiBalanceI,
          tokenBalanceA = _ref71.tokenBalanceA,
          tokenBalanceI = _ref71.tokenBalanceI;

      // validate params
      var methodName = "createChannelStateUpdateFingerprint";
      // validate
      // validatorOpts
      var isHex = { presence: true, isHex: true };
      var isHexStrict = { presence: true, isHexStrict: true };
      var isBN = { presence: true, isBN: true };
      var isAddress = { presence: true, isAddress: true };
      var isPositiveInt = { presence: true, isPositiveInt: true };
      var isBool = { presence: true, isBool: true };
      Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
      Connext.validatorsResponseToError(validate.single(isClose, isBool), methodName, "isClose");
      Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
      Connext.validatorsResponseToError(validate.single(numOpenThread, isPositiveInt), methodName, "numOpenThread");
      Connext.validatorsResponseToError(validate.single(threadRootHash, isHex), methodName, "threadRootHash");
      Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
      Connext.validatorsResponseToError(validate.single(partyI, isAddress), methodName, "partyI");
      Connext.validatorsResponseToError(validate.single(weiBalanceA, isBN), methodName, "weiBalanceA");
      Connext.validatorsResponseToError(validate.single(weiBalanceI, isBN), methodName, "weiBalanceI");
      Connext.validatorsResponseToError(validate.single(tokenBalanceA, isBN), methodName, "tokenBalanceA");
      Connext.validatorsResponseToError(validate.single(tokenBalanceI, isBN), methodName, "tokenBalanceI");
      // generate state update to sign
      var hash = Web3.utils.soliditySha3({ type: "bytes32", value: channelId }, { type: "bool", value: isClose }, { type: "uint256", value: nonce }, { type: "uint256", value: numOpenThread }, { type: "bytes32", value: threadRootHash }, { type: "address", value: partyA }, // address will be returned bytepadded
      { type: "address", value: partyI }, // address is returned bytepadded
      { type: "uint256", value: weiBalanceA }, { type: "uint256", value: weiBalanceI }, { type: "uint256", value: tokenBalanceA }, { type: "uint256", value: tokenBalanceI });
      return hash;
    }

    /**
     * Recovers the signer from the hashed data generated by the Connext.createChannelStateUpdateFingerprint function.
     *
     * @param {Object} params - the method object (representing channel state)
     * @param {String} params.sig - signature you are recovering signer from
     * @param {String} params.channelId - channelId
     * @param {Boolean} params.isClose - flag indicating whether or not this is closing state
     * @param {Number} params.nonce - the sequence of the channel update
     * @param {Number} params.numOpenThread - the number of open threads  associated with this channel
     * @param {String} params.threadRootHash - the root hash of the Merkle tree containing all initial states of the open threads
     * @param {String} params.partyA - ETH address of partyA in the channel
     * @param {String} params.partyI - ETH address of the hub
     * @param {BN} params.weiBalanceA - wei balance of partyA
     * @param {BN} params.weiBalanceI - wei balance of hub
     * @param {BN} params.tokenBalanceA - wei balance of partyA
     * @param {BN} params.tokenBalanceI - wei balance of hub
     *
     * @returns {String} the ETH address of the signer of this update.
     */

  }, {
    key: "recoverSignerFromChannelStateUpdate",
    value: function recoverSignerFromChannelStateUpdate(_ref72) {
      var sig = _ref72.sig,
          channelId = _ref72.channelId,
          isClose = _ref72.isClose,
          nonce = _ref72.nonce,
          numOpenThread = _ref72.numOpenThread,
          threadRootHash = _ref72.threadRootHash,
          partyA = _ref72.partyA,
          partyI = _ref72.partyI,
          weiBalanceA = _ref72.weiBalanceA,
          weiBalanceI = _ref72.weiBalanceI,
          tokenBalanceA = _ref72.tokenBalanceA,
          tokenBalanceI = _ref72.tokenBalanceI;

      var methodName = "recoverSignerFromChannelStateUpdate";
      // validate
      // validatorOpts
      var isHexStrict = { presence: true, isHexStrict: true };
      var isHex = { presence: true, isHex: true };
      var isBN = { presence: true, isBN: true };
      var isAddress = { presence: true, isAddress: true };
      var isPositiveInt = { presence: true, isPositiveInt: true };
      var isBool = { presence: true, isBool: true };
      Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");

      Connext.validatorsResponseToError(validate.single(sig, isHex), methodName, "sig");

      Connext.validatorsResponseToError(validate.single(isClose, isBool), methodName, "isClose");

      Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
      Connext.validatorsResponseToError(validate.single(numOpenThread, isPositiveInt), methodName, "numOpenThread");
      Connext.validatorsResponseToError(validate.single(threadRootHash, isHex), methodName, "threadRootHash");
      Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");
      Connext.validatorsResponseToError(validate.single(partyI, isAddress), methodName, "partyI");
      Connext.validatorsResponseToError(validate.single(weiBalanceA, isBN), methodName, "weiBalanceA");
      Connext.validatorsResponseToError(validate.single(weiBalanceI, isBN), methodName, "weiBalanceI");
      Connext.validatorsResponseToError(validate.single(tokenBalanceA, isBN), methodName, "tokenBalanceA");
      Connext.validatorsResponseToError(validate.single(tokenBalanceI, isBN), methodName, "tokenBalanceI");

      console.log("recovering signer from:", JSON.stringify({
        sig: sig,
        channelId: channelId,
        isClose: isClose,
        nonce: nonce,
        numOpenThread: numOpenThread,
        threadRootHash: threadRootHash,
        partyA: partyA,
        partyI: partyI,
        weiBalanceA: weiBalanceA.toString(),
        weiBalanceI: weiBalanceI.toString(),
        tokenBalanceA: tokenBalanceA.toString(),
        tokenBalanceI: tokenBalanceI.toString()
      }));
      // generate fingerprint
      var fingerprint = Connext.createChannelStateUpdateFingerprint({
        channelId: channelId,
        isClose: isClose,
        nonce: nonce,
        numOpenThread: numOpenThread,
        threadRootHash: threadRootHash,
        partyA: partyA,
        partyI: partyI,
        weiBalanceA: weiBalanceA,
        weiBalanceI: weiBalanceI,
        tokenBalanceA: tokenBalanceA,
        tokenBalanceI: tokenBalanceI
      });
      fingerprint = util.toBuffer(fingerprint);

      var prefix = Buffer.from("\x19Ethereum Signed Message:\n");
      var prefixedMsg = util.sha3(Buffer.concat([prefix, Buffer.from(String(fingerprint.length)), fingerprint]));
      var res = util.fromRpcSig(sig);
      var pubKey = util.ecrecover(prefixedMsg, res.v, res.r, res.s);
      var addrBuf = util.pubToAddress(pubKey);
      var addr = util.bufferToHex(addrBuf);

      console.log("recovered:", addr);
      return addr;
    }

    /**
     * Hashes data from a thread state update using web3's soliditySha3.
     *
     * @param {Object} params - the method object
     * @param {String} params.channelId - ID of the thread you are creating a state update for
     * @param {Number} params.nonce - the sequence of the state update
     * @param {String} params.partyA - ETH address of partyA
     * @param {String} params.partyB - ETH address of partyB
     * @param {BN} params.weiBalanceA - wei balance of partyA
     * @param {BN} params.weiBalanceB - wei balance of partyB
     * @param {BN} params.tokenBalanceA - wei balance of partyA
     * @param {BN} params.tokenBalanceB - wei balance of partyB
     * @param {BN} params.tokenBond - total token amount in thread
     * @param {BN} params.weiBond - total wei amount in thread
     *
     * @returns {String} hash of the thread state
     */

  }, {
    key: "createThreadStateUpdateFingerprint",
    value: function createThreadStateUpdateFingerprint(_ref73) {
      var channelId = _ref73.channelId,
          nonce = _ref73.nonce,
          partyA = _ref73.partyA,
          partyB = _ref73.partyB,
          weiBalanceA = _ref73.weiBalanceA,
          weiBalanceB = _ref73.weiBalanceB,
          tokenBalanceA = _ref73.tokenBalanceA,
          tokenBalanceB = _ref73.tokenBalanceB,
          weiBond = _ref73.weiBond,
          tokenBond = _ref73.tokenBond;

      var methodName = "createThreadStateUpdateFingerprint";
      // typecast balances incase chained
      var isPositiveBnString = { presence: true, isPositiveBnString: true };
      Connext.validatorsResponseToError(validate.single(weiBalanceA, isPositiveBnString), methodName, "weiBalanceA");
      Connext.validatorsResponseToError(validate.single(weiBalanceB, isPositiveBnString), methodName, "weiBalanceB");
      Connext.validatorsResponseToError(validate.single(tokenBalanceA, isPositiveBnString), methodName, "tokenBalanceA");
      Connext.validatorsResponseToError(validate.single(tokenBalanceB, isPositiveBnString), methodName, "tokenBalanceB");
      Connext.validatorsResponseToError(validate.single(weiBond, isPositiveBnString), methodName, "weiBond");
      Connext.validatorsResponseToError(validate.single(tokenBond, isPositiveBnString), methodName, "tokenBond");
      weiBalanceA = Web3.utils.toBN(weiBalanceA);
      weiBalanceB = Web3.utils.toBN(weiBalanceB);
      tokenBalanceA = Web3.utils.toBN(tokenBalanceA);
      tokenBalanceB = Web3.utils.toBN(tokenBalanceB);
      weiBond = Web3.utils.toBN(weiBond);
      tokenBond = Web3.utils.toBN(tokenBond);
      // validate
      var isHexStrict = { presence: true, isHexStrict: true };
      var isAddress = { presence: true, isAddress: true };
      var isPositiveInt = { presence: true, isPositiveInt: true };
      Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
      Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");
      Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");

      Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");

      var hubBondWei = weiBalanceA.add(weiBalanceB);
      var hubBondToken = tokenBalanceA.add(tokenBalanceB);

      if (!hubBondWei.eq(weiBond)) {
        throw new ThreadUpdateError(methodName, "Invalid weiBond supplied: " + weiBond.toString() + ". Expected: " + hubBondWei.toString());
      }

      if (!hubBondToken.eq(tokenBond)) {
        throw new ThreadUpdateError(methodName, "Invalid weiBond supplied: " + tokenBond.toString() + ". Expected: " + hubBondToken.toString());
      }

      // generate state update to sign
      var hash = Web3.utils.soliditySha3({ type: "bytes32", value: channelId }, { type: "uint256", value: nonce }, { type: "address", value: partyA }, { type: "address", value: partyB }, { type: "uint256", value: tokenBond }, { type: "uint256", value: weiBond }, { type: "uint256", value: weiBalanceA }, { type: "uint256", value: weiBalanceB }, { type: "uint256", value: tokenBalanceA }, { type: "uint256", value: tokenBalanceB });
      return hash;
    }

    /**
     * Recovers the signer from the hashed data generated by the Connext.createThreadStateUpdateFingerprint function.
     *
     * @param {Object} params - the method object
     * @param {String} params.sig - signature you are recovering signer from
     * @param {String} params.channelId - ID of the thread you are creating a state update for
     * @param {Number} params.nonce - the sequence of the state update
     * @param {String} params.partyA - ETH address of partyA
     * @param {String} params.partyB - ETH address of partyB
     * @param {BN} params.weiBalanceA - wei balance of partyA
     * @param {BN} params.weiBalanceB - wei balance of partyB
     * @param {BN} params.tokenBalanceA - wei balance of partyA
     * @param {BN} params.tokenBalanceB - wei balance of partyB
     * @param {BN} params.tokenBond - total token amount in thread
     * @param {BN} params.weiBond - total wei amount in thread
     *
     * @returns {String} ETH address of the signer
     */

  }, {
    key: "recoverSignerFromThreadStateUpdate",
    value: function recoverSignerFromThreadStateUpdate(_ref74) {
      var sig = _ref74.sig,
          channelId = _ref74.channelId,
          nonce = _ref74.nonce,
          partyA = _ref74.partyA,
          partyB = _ref74.partyB,
          weiBalanceA = _ref74.weiBalanceA,
          weiBalanceB = _ref74.weiBalanceB,
          tokenBalanceA = _ref74.tokenBalanceA,
          tokenBalanceB = _ref74.tokenBalanceB,
          weiBond = _ref74.weiBond,
          tokenBond = _ref74.tokenBond;

      var methodName = "recoverSignerFromThreadStateUpdate";
      // validate
      // typecast balances incase chained
      var isPositiveBnString = { presence: true, isPositiveBnString: true };
      Connext.validatorsResponseToError(validate.single(weiBalanceA, isPositiveBnString), methodName, "weiBalanceA");
      Connext.validatorsResponseToError(validate.single(weiBalanceB, isPositiveBnString), methodName, "weiBalanceB");
      Connext.validatorsResponseToError(validate.single(tokenBalanceA, isPositiveBnString), methodName, "tokenBalanceA");
      Connext.validatorsResponseToError(validate.single(tokenBalanceB, isPositiveBnString), methodName, "tokenBalanceB");
      Connext.validatorsResponseToError(validate.single(weiBond, isPositiveBnString), methodName, "weiBond");
      Connext.validatorsResponseToError(validate.single(tokenBond, isPositiveBnString), methodName, "tokenBond");
      weiBalanceA = Web3.utils.toBN(weiBalanceA);
      weiBalanceB = Web3.utils.toBN(weiBalanceB);
      tokenBalanceA = Web3.utils.toBN(tokenBalanceA);
      tokenBalanceB = Web3.utils.toBN(tokenBalanceB);
      weiBond = Web3.utils.toBN(weiBond);
      tokenBond = Web3.utils.toBN(tokenBond);
      // validatorOpts'
      var isHex = { presence: true, isHex: true };
      var isHexStrict = { presence: true, isHexStrict: true };
      var isBN = { presence: true, isBN: true };
      var isAddress = { presence: true, isAddress: true };
      var isPositiveInt = { presence: true, isPositiveInt: true };

      Connext.validatorsResponseToError(validate.single(sig, isHex), methodName, "sig");

      Connext.validatorsResponseToError(validate.single(channelId, isHexStrict), methodName, "channelId");
      Connext.validatorsResponseToError(validate.single(nonce, isPositiveInt), methodName, "nonce");

      Connext.validatorsResponseToError(validate.single(partyA, isAddress), methodName, "partyA");

      Connext.validatorsResponseToError(validate.single(partyB, isAddress), methodName, "partyB");

      var expectedWeiBond = weiBalanceA.add(weiBalanceB);
      var expectedTokenBond = tokenBalanceA.add(tokenBalanceB);

      if (!expectedWeiBond.eq(weiBond)) {
        throw new ThreadUpdateError("Invalid weiBond supplied: " + weiBond.toString() + ". Expected: " + expectedWeiBond.toString());
      }

      if (!expectedTokenBond.eq(tokenBond)) {
        throw new ThreadUpdateError("Invalid weiBond supplied: " + tokenBond.toString() + ". Expected: " + expectedTokenBond.toString());
      }

      console.log("recovering signer from:", JSON.stringify({
        sig: sig,
        channelId: channelId,
        nonce: nonce,
        partyA: partyA,
        partyB: partyB,
        weiBalanceA: weiBalanceA.toString(),
        weiBalanceB: weiBalanceB.toString(),
        tokenBalanceA: tokenBalanceA.toString(),
        tokenBalanceB: tokenBalanceB.toString(),
        weiBond: weiBond.toString(),
        tokenBond: tokenBond.toString()
      }));
      var fingerprint = Connext.createThreadStateUpdateFingerprint({
        channelId: channelId,
        nonce: nonce,
        partyA: partyA,
        partyB: partyB,
        weiBalanceA: weiBalanceA,
        weiBalanceB: weiBalanceB,
        tokenBalanceA: tokenBalanceA,
        tokenBalanceB: tokenBalanceB,
        weiBond: weiBond,
        tokenBond: tokenBond
      });
      fingerprint = util.toBuffer(fingerprint);
      var prefix = Buffer.from("\x19Ethereum Signed Message:\n");
      var prefixedMsg = util.sha3(Buffer.concat([prefix, Buffer.from(String(fingerprint.length)), fingerprint]));
      var res = util.fromRpcSig(sig);
      var pubKey = util.ecrecover(prefixedMsg, res.v, res.r, res.s);
      var addrBuf = util.pubToAddress(pubKey);
      var addr = util.bufferToHex(addrBuf);
      console.log("recovered:", addr);

      return addr;
    }
  }, {
    key: "generateThreadRootHash",
    value: function generateThreadRootHash(_ref75) {
      var threadInitialStates = _ref75.threadInitialStates;

      var methodName = "generateThreadRootHash";
      var isArray = { presence: true, isArray: true };
      Connext.validatorsResponseToError(validate.single(threadInitialStates, isArray), methodName, "threadInitialStates");
      var emptyRootHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
      var threadRootHash = void 0;
      if (threadInitialStates.length === 0) {
        // reset to initial value -- no open VCs
        threadRootHash = emptyRootHash;
      } else {
        threadInitialStates = threadInitialStates.map(function (threadInitialState) {
          if (!threadInitialState.channelId) {
            threadInitialState.channelId = threadInitialState.threadId;
          }
          return threadInitialState;
        });
        var merkle = Connext.generateMerkleTree(threadInitialStates);
        threadRootHash = Utils.bufferToHex(merkle.getRoot());
      }

      return threadRootHash;
    }

    /**
     * Creates a merkle tree of the thread initial states provided.
     *
     * @example
     * const threadInitialStates = await connext.getThreadInitialStates(channelId)
     * const mt = Connext.generateMerkleTree(threadInitialStates)
     *
     * @param {Object[]} threadInitialStates - an array of initial thread state objects
     */

  }, {
    key: "generateMerkleTree",
    value: function generateMerkleTree(threadInitialStates) {
      var methodName = "generateMerkleTree";
      var isArray = { presence: true, isArray: true };
      Connext.validatorsResponseToError(validate.single(threadInitialStates, isArray), methodName, "threadInitialStates");
      if (threadInitialStates.length === 0) {
        throw new Error("Cannot create a Merkle tree with 0 leaves.");
      }
      var emptyRootHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
      var merkle = void 0;
      var elems = threadInitialStates.map(function (threadInitialState) {
        // vc0 is the initial state of each vc
        // hash each initial state and convert hash to buffer
        var hash = Connext.createThreadStateUpdateFingerprint(threadInitialState);
        var vcBuf = Utils.hexToBuffer(hash);
        return vcBuf;
      });
      if (elems.length % 2 !== 0) {
        // cant have odd number of leaves
        elems.push(Utils.hexToBuffer(emptyRootHash));
      }
      merkle = new MerkleTree.default(elems);

      return merkle;
    }
  }, {
    key: "validatorsResponseToError",
    value: function validatorsResponseToError(validatorResponse, methodName, varName) {
      if (validatorResponse !== undefined) {
        throw new ParameterValidationError(methodName, varName, validatorResponse);
      }
    }
  }]);
  return Connext;
}();

module.exports = Connext;